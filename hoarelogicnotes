Plan:
1. Build a language for describing potential mesh,space, funcs dependencies for globals and the strand array.

Something like:
*if condition then mesha else meshb
*(mesh a or mesh b)
*mesh a

Somthing like:
tpl->a->b = ...
tpl->a->c = ...
a[i] = ... for any i

QUESTION:
---How could we go from "or" or "if condition" to a single one.
Answers:
--the condition could be trivial/determine by the constants.
--the condition could be split in time or abstracted over a function or extended

e.g.
if condition
m = mesh a
else
m = mesh b

f == ...

Then we could do
if condition
m = mesh a
f==
else
m = mesh b
f==
end

--The or statement will emerge in time. Could the function be split in time?
--Well, for a global variable, we could call different strand functions

--For strand variables? if the condition is consitent in someway, we can do this.
--Is an or actually possible?
--What about shared state via sphere, in global.

Mote: I am starting to reconsider doing this in simple as the non-ssa part is getting to me...


---------
Step 2:
Build a transformed simple that only represents transfer and storage of FEM Info
Mesh, space, func -- pure things and globals
position, cells
Things that depend on them (tuples with specific mappings)
Sequences represents as blocks
**Only statements are statements that use and produce fem data along with control flow.

-------
Step 3: Analysis pass

Skip constants
!Figure out initial inputs (only func, space, mesh!)
!Figure out global/global inits (possible conditions, but things like a = mesh1, a = mesh2 -> a only have mesh2; for loops (only at end))
!Functions (treat as inlined with information given as it currently is)
!Look at strand array initialization and record function setups
!Figure out initial strand array (strand state is where OR HAPPENS!!!!!!!! or other array concepts - (also see loops!!))
!symoblically run into we hit a fixed point. Since there are finitely many mesh, func, space, we should hit one quickly

!symoblic rules:
!!Run a strand:
--State vars changing introduces an or
--local vars are easy as pure SSA
--sphere means we read from state var
--reductions are tricky - we ask about itterators maybe
!!Run stabalization:
--Same as above
!!Run the global update:
---Modifiy globals
---we have blank updates
---we have conditional updates
---we have an or introduced by potential loops or uncertainy or reading from states that have ors

--If anything has changed, run again.

!Funcions (look at inlined versions again)

Stage 4:
Do translations:
--mark single ones to be changed into globals
--if any ors, we create an array
--mark larger ones to be changed into tuples: data, int
--global fems that change turn into indecies that loop in.
--Translate FemOpts


---------
Consider related work:
Hoare logic
Process eperation logic?
BSP and formal verificaiton: https://www.researchgate.net/publication/279263833_BSP-Why_un_outil_pour_la_verification_deductive_de_programmes_BSP_machine-checked_semantics_and_application_to_distributed_state-space_algorithms


Note: need more clear algo!
Lesson: conditional probably not a good idea.
---------------
Interaction with other features:
-This makes T_i T_i^-i inverse optimizations more likely
-this makes the paper argument better

-For affine stuff, we desire the cancellation optimization - we should only type error for prence of the global inverse of affine things.
-Alternatives: don't - just use [] and include a warning latter on. Warning sounds better.
--Better:type error for the global inverse

-Reconsider overall field setup.
-Does this support our fast math optimizatoins?
-How does this impact the rewrites later on?
--Main places are in translate and probe.
--Guess: If we normalize called functions to have a wrapper with fem info (inlineable) and then the actual function, then this would be more workable because translate and probe wouldn't have to worry to much about getting types write - they could just call the wrapped funtions!

New plan:
--Fix FEM AST generation to use function wrapping/Take time to do other inserts and maybe figure out class for calling (Think about this closely isn't a bad idea... need to circumvent the inverse -> Actually, paramteric represetnation and bonding boxes - ugg - leave as a black box and include use of geometric data structure - Best solution inside an element is testing via euler - outside an element is another matter - in that case, geometric data structure +BS + Not my problem ideally, but maybe idea to support it.)
IDEA: Use class methods for giving that information and otherwise leave it as a black box. Create a directive to make class methods (property of a function -> even a way of doing this in the real thing)
SECOND IDEA STATED: Note that useful without an FFI -> Sounds like python honestly... -> add new inserts -> external function
JUST FUCK RAY TRACING APPLICATIONS, but read fuckers who scooped: https://hal.archives-ouvertes.fr/hal-02507361/document


--Clean up FEMopts and their use to make more practiced
--Build in Base eval
