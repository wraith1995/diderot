#version 3.0
//we first define quaternions:
type tensor[4] quat;
type quat[4] hmm;

//we set two random quats to show off how they are made.
quat q0 = quat([4,3,2,1]);
quat q1 = quat([1,2,3,1]);

function real  rand (tensor[5] a){
  real z = 2;
  foreach (int j in 0..5){
    z+=|a|+j;
  }
  return z;
}


overload quat +  (quat x, quat y){
  //since quats were defined with tensors, the inherit indexing:
  quat result = quat(x.unpack() + y.unpack());
  //we could simplify this via allowing a general unpack e.g:
  //quat result = quat x.unpack() + y.unpack() -> what to call unpack?
  return result;
}

overload quat -  (quat x, quat y){
  quat result = quat(x.unpack() - y.unpack());
  return result;
}
overload quat -  (quat x){
  quat result = quat([0,0,0,0]-x.unpack());
  return result;
}


overload real •  (quat x, quat y){
  real result = x.unpack() • y.unpack();
  return result;
}

overload quat *  (quat x, real y) {return quat(y * x.unpack());}
overload quat *  (real y, quat x) {return quat(y * x.unpack());}

function quat conj(quat x0){
  tensor[4] x = x0.unpack();
  return(quat([x[0], -x[1], -x[2], -x[3]]));
}


//we can now define two useful functions:

//First, we define the distance between two quaternions as orientations:


function real oreintDist (quat x, quat y){
  
  quat x0 = x * (1/sqrt(x • x ));
  quat y0 = y * (1/sqrt(y • y ));
  return 1 - (x0 • y0 )^2; 
}

//Using this function, you can compare two unit normals; thus, I could color a surface by how much its outward pointing normal deviated from some reference normal!

//we define some helpers via
//https://www.plunk.org/~hatch/rightway.php (C-x C-f slerp) for special comments
//This is just to make sure it is right, but I think I can find a more numerically sound
//method on the basis of oreintdist(x,y) = (1 - cos(\theta))/2 where
//theta is the angle between the two orientations.
function real sinOverX(real ang)  = 1 if ang*ang + 1 == 1 else sin(ang)/ang;
function real angBet(quat x, quat y) {
  real dot = x • y;
  if (dot < 0){
    real arc = sqrt((-x-y) •( -x-y ))/2;
    return π - 2 * asin(arc);
  }
  else{
    real arc = sqrt((x-y) •( x-y ))/2;
    return 2 * asin(arc);
  }
}
//Source: https://en.wikipedia.org/wiki/Slerp
//Second, we can define the interpolation between two unit quaternions; in essence, the path given by t\in [0,1] \to slerp(x,y,t) is the geodesic on the unit sphere between the two positions on the sphere; another way of thinking of it is you parallel transport x to y.
//Using this function, one can rotate  the sphere in a principled and constant time manner.
//I hope we can find some application for that.
function quat slerp (quat x0, quat y0, real t){
  quat x = x0 * (1/sqrt(x0 • x0 ));
  quat y = y0 * (1/sqrt(y0 • y0 ));
  real ang = angBet(x,y);
  quat result = x * (sinOverX((1-t) * ang)/sinOverX(ang)) * (1-t) + y * (sinOverX(t*ang)/sinOverX(ang)) *t;
  return result;
}


//next we define multiplication:

overload quat *  (quat x0, quat y0){
  tensor[4] x = x0.unpack();
  tensor[4] y = y0.unpack();
  quat result = quat([x[0]*y[0] - x[1]*y[1] - x[2]*y[2] - x[3]*y[3],
		      x[0]*y[1] - x[1]*y[0] + x[2]*y[3] - x[3]*y[2],
		      x[0]*y[2] - x[1]*y[3] + x[2]*y[0] + x[3]*y[1],
		      x[0]*y[3] - x[1]*y[2] - x[2]*y[1] + x[3]*y[0]]);
  return result;
}

//we define division:
overload quat /  (quat y, quat x) { // is y/x
  quat invx = conj(x) * (x • x); // 1/x;
  return y*invx;
}

/* function quat rotateBetween(vec3 x, vec3 y){ */ 
/*   vec3 start = x × y; */
/*   real dot = x •( y ); */
/*   //need to check case where x== y or  */
/*   real w = sqrt(x •( x ) * y •( y )) + dot; */
/*   quat result = quat([w,start[0],start[1],start[2]]); */
/* } */

strand f(int i) {
  real b=  1;
  quat z1 = quat([0,0,0,0]);
  output real a = oreintDist(q0,q1);
  output tensor[4] frm = slerp(q0,q1,0.5).unpack();
  output real q = rand([1,0,0,0,0]);
  update {
    real z = 2;
    foreach (int j in 0..5){
      z+=|b|+j;
      z1+=q1;
    }
    print(q," ",z," ", z1.unpack() ," ",frm,"\n");
    stabilize;
  }
}
create_array { f(i) | i in 0..1};
