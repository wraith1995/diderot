#version 3.0
type mesh msh = file("evalProg.json");
const int dim = msh.dim;

input msh a;

input real isoval = 0.2;  input real thick = 0.07;
input vec3 camEye = [3.0,-3.0,3.0];  input vec3 camAt = [0.5,0.5,0.5];   input vec3 camUp = [0,0,1];
input real camFOV = 13.7;  input int iresU = 10;    input int iresV = 10;
input real camNear = -2; input real camFar = 5; // NOTE: missing from paper: sloppy code condensing
input real refStep = 1.0; input real rayStep =0.01;
input vec3 lightVsp = [0.0, 0.0, 1.0]; // light direction in view-space
input real phongKa = 0.1; input real phongKd = 0.9;

input bool debug = false;
input int debugU = 8;
input int debugV = 2;
input real eps = 0.00000001;

real camDist = |camAt - camEye|;
real camNearVsp = camNear + camDist; 
real camFarVsp = camFar + camDist;   
vec3 camN = normalize(camAt - camEye); // away
vec3 camU = normalize(camN × camUp);    // right
vec3 camV = camU × camN;                // up
real camVmax = tan(camFOV*π/360)*camDist;
real camUmax = camVmax*iresU/iresV;
vec3 light = transpose([camU,camV,camN])•normalize(lightVsp);


refCell{msh} R = a.refcell();
strand ray(int ui, int vi) {
  real rayU = lerp(-camUmax, camUmax, -0.5, ui, iresU-0.5);       
  real rayV = lerp(-camVmax, camVmax, -0.5, vi, iresV-0.5);
  vec3 UV = rayU*camU + rayV*camV;
  
  output vec3 rayOrig = camEye + UV;
  output vec3 rayVec = camN + [0,0,0]; 
  output real camNearVsp = camNearVsp;
  output real camFarVsp = camFarVsp;
  vec3 rayStart = rayOrig + camNearVsp * rayVec;
  tensor[dim] rayStartProj = [rayStart[0], rayStart[1]];
  vec3 rayEnd = rayOrig + camFarVsp * rayVec;
  vec3 dpos = (rayEnd - rayStart);
  tensor[dim] dposProj = [dpos[0], dpos[1]];
  output position{msh}[] poses = {};
  output real[] normalizedTimes = {};
  int cellIntersects = 0;
  output vec2[] rayCellInter = {};
  output tensor[3][] spaceInter = {};
  output tensor[dim][] refSpaceInter = {};
  output cell{msh}[] cellInter = {};
  int currentCellInt = -1;
  real rayN = 0;
  cell{msh} currentCell = a.cells[0];
  int steps = 0;

  vec3[] umm1 = {};
  vec3[] umm2 = {};

  position{msh} pos = a.invalidPos();
  bool startsInside = false;
  start {
    real startTime = camFarVsp;
    if ((ui != debugU || vi != debugV) && debug){
      stabilize;
    }
    foreach (cell{msh} c in a.cells())
      {
	//print("Cell:",c,"\n");
	if (c.isInside(rayStartProj)){
	  //print("pos starts inside\n");
	  position{msh} p = c.meshPos(c.inverseTransform(rayStartProj));
	  poses = poses@p;
	  normalizedTimes = normalizedTimes@camNearVsp;
	  startTime = camNearVsp;
	  currentCellInt = cellIntersects;
	  cellIntersects+=1;
	  startsInside = true;
	}
	else {
	  real newTime = c.enter(rayStartProj, dposProj);

	  ////print(rayStart, dpos, newRayStart, newDpos, newTime,"\n");
	  if (newTime >= 0.0){
	    position{msh} p = c.enterPos(rayStartProj, dposProj);
	    real newRayTime = lerp(camNearVsp,camFarVsp, newTime);
	    //Is this lerp correct?
	    normalizedTimes = normalizedTimes@newRayTime;
	    poses = poses@p;
	    if (startTime > newRayTime){startTime  = newRayTime; currentCellInt = cellIntersects;}
	    cellIntersects+=1;
	  }
	}
	
      }
    ////print("Cells:",cells,"\n");


    if (cellIntersects != 0){
      pos = poses[currentCellInt];
      rayN = normalizedTimes[currentCellInt];
      spaceInter = spaceInter@{rayOrig, rayOrig + rayN*rayVec};
      refSpaceInter = {pos.refPos};
      currentCell = pos.mc;
      cellInter = {currentCell};
      //print("In the interval:", [camNearVsp, camFarVsp], "\n");
      //print("Possible times:", normalizedTimes, "\n");
      //print("cells:", {p.mc | p in poses}, "\n");
    } else {
      //print("Seg: No intersection!\n");
      //print("Ui: ", ui, " Vi:", vi,"\n");
      stabilize;}


  }


  update {
    //print("Ui: ", ui, " vi: ", vi, "\n");
    //print("The current ref pos is:", pos.refPos, "\n");
    //print("Current cell:", pos.mc, "\n");
    //print("The current time is:", rayN, "\n");
    //print("The current world pos is:", pos.worldPos(), "\n");
    vec3 stupid = rayOrig + rayN * rayVec;
    //print("The current world pos should be:",[stupid[0], stupid[1]] , "\n");

    if (!(R.isInside(pos.refPos))){
      //print("nerror: invalid pos created\n");
      if(!startsInside){
	//print("Not because of an inside\n");
      }
    }
    //print("The current world pos is:", pos.worldPos(), "\n");

    vec3 cpos = rayOrig + rayN * rayVec;
    //print("The current world pos should be:", [cpos[0], cpos[1]] , "\n");
    real err = |pos.worldPos() - [cpos[0], cpos[1]]|;
    if ( err > 0.00001){
      //print("nerror:Warning! Moved off ray:", err, "\n");
    }
    else{
      //print("Did not move off ray!\n");
    }
    steps+=1;

    //print("Orig:", rayOrig, " dir:", rayVec, "\n");
    vec3 startPos = rayOrig + rayN * rayVec;
    vec3 newDpos = (camFarVsp - rayN) * rayVec;
    real nextTime = pos.exit([newDpos[0], newDpos[1]]);
    real rayN' = max(rayN, min(camFarVsp, lerp(rayN, camFarVsp, nextTime)));

    //print("Next time:", nextTime, "\n");
    if (nextTime >= 0){
      rayCellInter = rayCellInter@[rayN,rayN'];
      rayN = rayN';
      position{msh} pos' = pos.exitPos([newDpos[0], newDpos[1]]);
      if (rayN >= camFarVsp){
	//print("cells: ",cellInter,"\n");
	spaceInter = spaceInter@(rayOrig + camFarVsp * rayVec);
	stabilize;}

      spaceInter = spaceInter@(rayOrig + rayN * rayVec);
      refSpaceInter = refSpaceInter@(pos'.refPos);

      if (pos'.isValid()){

	pos = pos';
	//print("Next cell:", pos.mc, "\n");
	currentCell = pos.mc();
	cellInter = cellInter@currentCell;
	continue;
      }
      else {}
	//print ("Invalid\n");
      }
      int newIdx = -1;
      real estimate = camFarVsp;
      foreach (int i in 0..(cellIntersects-1)){
	real t = normalizedTimes[i];
	position{msh} pos' = poses[i];
	if (t >= rayN && estimate >= t && pos'.mc != pos.mc){
	  estimate = t;
	  newIdx = i;
	}
      }
      if (newIdx > -1){
	//print("nerror:Impossible happened\n");
	if(startsInside){
	  //print("because of an inside\n");
	}
	//print("Direction:", rayVec, "\n");
	//print("world pos was:", pos.worldPos(), "\n");
	//print("Interior pos was:", pos.refPos, "\n");
	//print(normalizedTimes, " at ", newIdx, "\n");
	//print("Original time was:", rayN, "\n");
	pos = poses[newIdx];
	currentCell = pos.mc();
	cellInter = cellInter@currentCell;
	////print("Idx:",newIdx,"\n");
	////print("Cells:",cells,"\n");
	////print(currentCell,"\n");
	rayN = normalizedTimes[newIdx];
	continue;
      } else { ////print(cellInter, "\n"); //print(rayCellInter, "\n");//print(spaceInter,"\n");
	//print("Enter times:", normalizedTimes, "\n");
	//print("Ray enter times:", rayCellInter, "\n");
	//print("cells:", cellInter,"\n");
	//print("End\n");
	//      //print(rayOrig);
      
	stabilize;}
      

    
  }
} create_array {ray(ui,vi) | vi in 0..iresU-1, ui in 0..iresV-1};
