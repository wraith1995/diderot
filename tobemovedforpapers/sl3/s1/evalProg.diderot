#version 3.0


type mesh mesh_t = file("evalProg.json");
const int dim = mesh_t.dim;
type functionSpace{mesh_t}[dim] fns_t = file("evalProg.json");
type femFunction{fns_t} func_t = file("evalProg.json");

input mesh_t meshData;
input fns_t space = fns_t(meshData);
input func_t data = func_t(space);
refCell{mesh_t} simplex = meshData.refcell();
input int timeSteps=32;
input real timeEps = 0.0000001;
input real errorMax = 0.0000001;
input int second = 0;

overload position{mesh_t} + (position{mesh_t} x, tensor[dim] dPos)
{
  if (!x.isValid()){
    //identity on invalid pos.
    //this way if something becomes invalid
    //the program keeps chuging along without failing
    //until the strand checks the validity and dies cleanly.
    return(x);
  }
  real time = 1; //time keeping
  position{mesh_t} cmp = x; //current mesh pos
  // NOTE: This could be replaced by a while loop over time,
  // but I don't want to add while loops
  foreach (int i in 0..timeSteps ){ //for loop
    tensor[dim] deltaP =  inv(∇⊗(cmp.mc.transform)(cmp.refPos)) • dPos + second * 0.5 * ((∇⊗(inv(∇⊗(cmp.mc.transform)))(cmp.refPos)) • dPos ) • dPos ; //project velocity
    tensor[dim] normDetaP = deltaP/|deltaP|;
    //time * (DT(x))^{-1} •( dpos )
    tensor[dim] newPos = cmp.refPos + time * deltaP;
    //print("At s:", newPos, "\n");
    if (simplex.isInside(newPos)) { //we did not leave the refrence so we are done
      position{mesh_t} nmp = cmp.mc.meshPos(newPos); //newMeshPos
      return(nmp);
    }
    else {
      real eTime = simplex.exit(cmp, normDetaP); //expended time where 1 means we went to the full thing... - we want time for time * deltaP - 1 is time * delta
      if(eTime == -1){
	// print("stupid fail\n");
	cmp = meshData.findPos(x.worldPos() + dPos);
	return(cmp);
      }
      time-=eTime / |deltaP|; 
	    
      position{mesh_t} nmp = simplex.exitPos(cmp, normDetaP);//get next cell and position in it.
      if ( !nmp.isValid || eTime < 0 ||  time < timeEps){
	return(nmp);
      }
      cmp = nmp;
    }
  }
  //  print("stupid fine\n");
  cmp = meshData.findPos(x.worldPos() + dPos);
  return(cmp);
}


input tensor[dim][] startPoints;
input real stepSize = 0.01;
input int stepMax = 32;

function tensor[dim] nV(position{mesh_t} x){
  if(x.isValid()){
    cell{mesh_t} c = x.mc;
    tensor[dim] ref = x.refPos();
    tensor[dim] val = data.funcCell(c).refField(ref);
    return(val/|val|);
  }
  else
    {
      print("Error:Eval at Invalid\n");
      return(zeros[dim]);
    }
    
}
strand gg(tensor[dim] startPos){
  output tensor[dim][] stream = {};
  int step = 0;
  bool validAtEnd = true;
  position{mesh_t} cPos = meshData.findPos(startPos);
  update {//if not valid, get out
    if(!cPos.isValid()  || step == stepMax){
      validAtEnd = cPos.isValid;
      print("validity of ", startPos, " at end:", cPos.isValid, "\n");
      stabilize;}
    stream = stream@{cPos.worldPos()};
    position{mesh_t} intermed = cPos + 0.5 * stepSize * nV(cPos);
    if(!intermed.isValid){
      validAtEnd = false;
      print("validity of ", startPos, " at end:", validAtEnd, "\n");
      stabilize;
    }
    cPos = cPos +  stepSize * nV(intermed);
    step+=1;
  }
} create_collection {gg(x) | x in startPoints};
