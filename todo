Tomorrow:
-Fix const missing other things -> subscript
-Fix sequences not giving us types for tensors or maybe the other way???
-Load mesh
-Transforms down the way!


Ongoing issue:
-allow translation of DOF in two ways.
-Pointer issue of when things should be pointers
-Loading in NRRDS
-Loading of files, constants, etc
-Inserting of strings
-Use of that libindex
-CheckIR
-Email Kirby
-Misuse of degree vs spaceDim -> ops
---USE AST THING TO PARSE CONSTANTS??? - NO BECAUSE JSON
Continue MeshCell: Transformsm

-1.
0. Pointer issues - globals and internals are values - we need maps
1. Equality testing of all of these things
2. Load in via nrrd
3. Loading of files
4. Inserting of strings
5. Check High -> need to make opts more useful 
Email Kirby with functionality

Next steps:
Add ooptiona indexMap', vertMap to msh -> Later for verticies
Figure out transformDofs dimensions again
Deploy transformDofs as opt Dofs -> translates into getIndicies (seq) and get vals (tensor)

Transate:
Clarify FemOpt -> kind of like EIN almost
High (Big selectors)
Mid (Index/Other)
Low (scalars)
tree


Get Mesh
Get Index
Grab Indecies
Grab Tensors 

To do it:
add removal of () in select
Select continuations from hadown env -> insert code from new env
NOT EINMK op, but rather use Ops -> loadIndex -> for vertMap if not there, just be done
Push towards full meshCell functionarl:

immediate: transformDofs, isValid (think about layout of data for transformDofs)
Next: verticies, isInside (require the loaded file)
Next: transform, invTransform

Data:
natural iso -> properties we put on our functors -> so what does \alpha actually do -> equivelance in the category of functors: all maps that I want in the past can be rebuilt. There exist G' so that I can go backwards -> I can use alpha to build that G

We ought to be able to invert:
--with truly right software, you just pick categories and generate maps between them
--or auto-check methods between them

------
Final: meshPos stuff after meshPos
























1. Pass by value vs. by reference - deal with the pointer issues - everything should be passed by reference here probably.
2. Write these methods with proper C++ isms.
----------HERE WE ARE
4. Deal with cell issues and formalize it
5. Think about it accordance with meshPos
6. Implement cell stuff -> espcially transform and inverse transform
7. IMplement meshPos after thinking and figure out details about that
8. Implement finding MeshPos
9. Implement the global field
10. Mop Up.
11. Implement cell meta data
---Constants need to be in this
1. Select for just values -> function(method) resolution.






Today:
---make functions in the ast? Nah. Probably not.
-Add mesh select from space.
-Add Type of
-Add mesh numCell
-Fix select - remember select also needs to do fields and well fields -- need to update type env fr fields?

--Next step is to do cells -> cellToIndex and IndexToCell as well ass -> unique global var.
--> Here numCell can be used implictly -> need to add LoadFemThing -> expand in like mid to low to index shit.

So cells are pairings of femdata and ints ->
How do we deal with this?
(Mesh, int) -> int
int * int is also an option.

This gives a few optoins.
Reflection:
cells are effectively indicies that are given meaning on a mesh:
look in simplify: first we preprocess and look at our various cell sequences

Given a cell variable, can it uniquely be traced back to one mesh at all times? Then we can replace it with an index.
CellToIndex(cell)
IndexToCell(i, mesh)
















1. Clean up error messages and provide more information in them
2. Clean up the documentation
3. Determine if clean AST is needed.
4. Fix the for loop issues.
5. Load constants via files and use them
6. Determine any default constants.
7. Make sure named types can't occupy names of old types?
8. Make fields possible arguments to functions
9. Deal with inputs of named types