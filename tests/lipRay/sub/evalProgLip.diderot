#version 3.0
type mesh msh = file("evalProg.json");
type functionSpace{msh}[] fns = file("evalProg.json");
type femFunction{fns_t} func = file("evalProg.json");

const int dim = msh.dim;

input msh a;
input fns b = fns(a);
input func c = func(b);



input real isoval = 0.2;  input real thick = 0.07;
input vec3 camEye = [3.0,-3.0,3.0];  input vec3 camAt = [0.5,0.5,0.5];   input vec3 camUp = [0,0,1];
input real camFOV = 13.7;  input int iresU = 10;    input int iresV = 10;
input real camNear = -2; input real camFar = 5; // NOTE: missing from paper: sloppy code condensing
input real refStep = 1.0; input real rayStep =0.01;
input vec3 lightVsp = [0.0, 0.0, 1.0]; // light direction in view-space
input real phongKa = 0.1; input real phongKd = 0.9;

input bool debug = false;
input int debugU = 8;
input int debugV = 2;
input real eps = 0.000001;

input int[10][10][2] indecies;
input vec2[] times;
input cell{msh}[] cells;

real camDist = |camAt - camEye|;
real camNearVsp = camNear + camDist; 
real camFarVsp = camFar + camDist;   
vec3 camN = normalize(camAt - camEye); // away
vec3 camU = normalize(camN × camUp);    // right
vec3 camV = camU × camN;                // up
real camVmax = tan(camFOV*π/360)*camDist;
real camUmax = camVmax*iresU/iresV;
vec3 light = transpose([camU,camV,camN])•normalize(lightVsp);
vec3 rayVec = camN;
function int sign(real x){
  if (x > 0.0) {return(1)}
  else if (x < 0.0){return(-1)}
  else {return(0)}
}
refCell{msh} R = a.refcell();
strand ray(int ui, int vi) {
  real rayU = lerp(-camUmax, camUmax, -0.5, ui, iresU-0.5);       
  real rayV = lerp(-camVmax, camVmax, -0.5, vi, iresV-0.5);
  vec3 UV = rayU*camU + rayV*camV;
  vec3 rayOrig = camEye + UV;
  output vec2[] intervals = {};
  output cell{msh} newCells = {};
  int offset = indecies[ui][vi][0];
  int len = indecies[ui][vi][1];
  int itter = 0;
  cell{msh} cc = cells[offset + itter];
  cell{func} fc = c.funcCell(cc);
  
  vec2 interval = times[offset + itter];
  real start = interval[0];
  real end = interval[1];
  start {
    if (debug && ((ui != debugU) || (vi != debugV))){stabilize;}
  }

  
  update {
    vec3 rayStart = rayOrig + rayVec * start;
    vec2 project = [rayStart[0], rayStart[1]];
    real f0 = (fc.F ∘ c.invTransform)(project);

    if (eps >= f0/c.L){
      real gradEps = max(rayVec • ∇(fc.F ∘ c.invTransform)(project)/c.G, end - start);
      real f1 = (fc.F ∘ c.invTransform)(project + gradEps * [rayVec[0], rayVec[1]]);
      if (sign(f0) * sign(f1) > 0){
	start+=gradEps;
      }
      else {
	real epsUpdate = max(eps, gradEps);
	intervals=intervals@{start, start + epsUpdate};
	newCells=newCells@c;
	start+=epsUpdate;
      }
    } else {
      starts+=max(eps,f0/c.L);
    }
    
    if (start >= end){
      itter+=1;
      if(itter >= len){ stabilize;} else {
	interval = times[offset+itter]; cc = cells[offset + itter];
	start = interval[0]; end = interval[1];
	fc = c.funcCell(cc);
      }
    }
    
    


  }
  
} create_array {ray(ui,vi) | vi in 0..iresU-1, ui in 0..iresV-1};
