#version 3.0
input real isoval = 0.2;  input real thick = 0.07;
input vec3 camEye = [3.0,-3.0,3.0];  input vec3 camAt = [0.5,0.5,0.5];   input vec3 camUp = [0,0,1];
input real camFOV = 13.7;  input int iresU = 10;    input int iresV = 10;
input real camNear = -2; input real camFar = 5; // NOTE: missing from paper: sloppy code condensing
input real refStep = 1.0; input real rayStep =0.01;




type mesh msh = file("evalProg.json");
type functionSpace{msh}[] fns = file("evalProg.json");
type femFunction{fns} func = file("evalProg.json");
input msh a;
input fns b = fns(a);
input func c = func(b);
input real eps = 0.000001;



real camDist = |camAt - camEye|;
real camNearVsp = camNear + camDist; 
real camFarVsp = camFar + camDist;   
vec3 camN = normalize(camAt - camEye); // away
vec3 camU = normalize(camN × camUp);    // right
vec3 camV = camU × camN;                // up
real camVmax = tan(camFOV*π/360)*camDist;
real camUmax = camVmax*iresU/iresV;



input int[] indecies;//[2][10][10]
input vec2[] times;//intervals
input int[] cells;//cell indecies
//color:
input vec3 mcnear ("material color at near clipping plane (for depth cuing)") = [1,1,1];
input vec3 mcfar ("material color at far clipping plane") = [1,1,1];
input image(1)[3] cmap ("univariate colormap") = load_image("/home/teocollin/gitcode/diderot/tests/lipRay/find/cmap.nrrd");
input real cmin ("value mapped to min end of colormap") = 0.0;
input real cmax ("value mapped to max end of colormap. By default cmin==cmax==0, which disables this colormapping") = 1.0;
field#0(1)[3] CM = tent ⊛ clamp(cmap);
//light:
input bool light = true;
input real phongKa ("Blinn-Phong ambient component") = 0.5;
input real phongKd ("Blinn-Phong diffuse component") = 0.5;
input real phongKs ("Blinn-Phong specular component") = 0.0;
input real phongSp ("Blinn-Phong specularity exponent") = 60;
input real maxAlpha ("maximum opacity on rendered surface") = 1;
input vec3 lightVsp = [0.0, 0.0, 1.0]; // light direction in view-space
vec3 L = transpose([camU,camV,camN])•normalize(lightVsp);



function int sign(real x){
  if (x > 0.0) {return(1);}
  else if (x < 0.0){return(-1);}
  else {return(0);}
}

strand ray(int ui, int vi){
  real rayU = lerp(-camUmax, camUmax, -0.5, ui, iresU-0.5);       
  real rayV = lerp(-camVmax, camVmax, -0.5, vi, iresV-0.5);
  vec3 UV = rayU*camU + rayV*camV;
  
  vec3 rayOrig = camEye + UV;
  vec3 rayVec = camN + [0,0,0]; 
  real camNearVsp = camNearVsp;
  real camFarVsp = camFarVsp;
  vec3 rayStart = rayOrig + camNearVsp * rayVec;
  int offset = indecies[ui * iresV + vi];//indecies[0][ui][vi];
  int len = indecies[iresU*iresV + ui * iresV + vi ];//indecies[1][ui][vi];
  int itter = 0;
  int intersectionItter = 0;
  int idx = offset + itter;
  vec2 interval = times[idx];
  real s = interval[0];
  real e = interval[1];
  cell{msh} cc = a.cells[0];
  cell{func} fc = (c.funcCell)(cc);
  bool newton = true;
  output real out = 0;
  output vec4 rgba = [0,0,0,0];

  start{
    if(len == 0){stabilize;}
    cc = a.cells[cells[idx]];
    fc = c.funcCell(cc);
  } 
  
  update {
    print("Interval:", [s,e],"\n");
    print("inner itter:",intersectionItter,"\n");
    print("Outer itter:",itter,"\n");
    vec2 startRay = [rayOrig[0], rayOrig[1]] + s * [rayVec[0], rayVec[1]];
    vec2 endRay = [rayOrig[0], rayOrig[1]] + e * [rayVec[0], rayVec[1]];
    vec2 invertA = cc.inverseTransform(startRay);
    vec2 invertB = cc.inverseTransform(endRay);
    print("inverses:", invertA, invertB,"\n");
    real faVal = fc.refField(invertA);
    real fa = faVal - rayVec[2]*s - rayOrig[2];
    real fb = fc.refField(invertB) - rayVec[2]*e - rayOrig[2];
    print("Vals:",[fa,fb],"\n");
    if (|fa - fb| < eps && |fa| > eps){
      s+=eps;
      continue;
    }
    real cup = (s* fb - e*fa)/(fb -fa);
    print("Mid time:", cup, "\n");
    vec2 midRay = [rayOrig[0], rayOrig[1]] +  cup * [rayVec[0], rayVec[1]];
    vec2 invertC = cc.inverseTransform(midRay);
    real fmVal = fc.refField(invertC);
    real fm = fmVal - rayVec[2]* cup  - rayOrig[2];
    print("all vals:",[fa, fm, fb],"\n");
    intersectionItter+=1;
    if (sign(fa)* sign(fm) < 0){
      e = cup;

    }
    else if (sign(fa)* sign(fm) > 0)
      {
	s = cup;
      }
    print("new interval:", [s,e],"\n");
    //I think |fa| < eps and |fb| < eps are impossible... but double check
    if (|fa| < eps || |fm| < eps || intersectionItter > 32){
      intersectionItter = 0;
      if (|fm| > eps && |fa| > eps) {
	itter+=1;
	if(itter >= len){print("Fin pixel=============================\n");stabilize;}
	interval = times[offset+itter]; cc = a.cells[cells[offset + itter]];
	s = interval[0]; e = interval[1];
	fc = c.funcCell(cc);
	print("Next interval!\n");
	continue;}
      else{
	vec2 grad = [0,0];
	vec3 loc = rayOrig;
	if (|fm| < eps){
	  grad = ∇ ( fc.refField ∘ cc.inverseTransform)(midRay);
	  out = fmVal;
	}
	if (|fa| < eps){
	  cup = s;//book keeping
	  grad = ∇ ( fc.refField ∘ cc.inverseTransform)(startRay);
	  out = faVal;
	}
	print("Out val:",out,"\n");
	print("Grad val:",grad,"\n");
	vec3 mcol = [1,1,1];
	if (cmin != cmax){
	    mcol = CM(lerp(-1, 1, cmin, out, cmax));
	}
	if(light){
	  vec3 N = [grad[0], grad[1], -1];
	  vec3 H = normalize(-normalize(rayVec)+L);
	  vec3 lightColor = lerp(mcnear, mcfar, camNearVsp, cup, camFarVsp);
	  
	  vec3 ambientTerm = phongKa * mcol;
	  vec3 diffuse = phongKd * modulate(mcol,lightColor)*max(0,N•L);
	  vec3 specular = phongKs*lightColor*((max(0,N•H))^phongSp);
	  vec3 fin = ambientTerm + diffuse + specular;
	  rgba = [fin[0],fin[1],fin[2],1];
	} else {
	  rgba = [mcol[0],mcol[1],mcol[2],1];
	}
	stabilize;
      }
    }
    else
      {print("=========\n");}
    
    //

    
  }
    
    
} create_array {ray(ui,vi) | vi in 0..iresU-1, ui in 0..iresV-1};
