#version 3.0
input real isoval = 0.2;  input real thick = 0.07;
input vec3 camEye = [3.0,-3.0,3.0];  input vec3 camAt = [0.5,0.5,0.5];   input vec3 camUp = [0,0,1];
input real camFOV = 13.7;  input int iresU = 10;    input int iresV = 10;
input real camNear = -2; input real camFar = 5; // NOTE: missing from paper: sloppy code condensing
input real refStep = 1.0; input real rayStep =0.01;




type mesh msh = file("evalProg.json");
type functionSpace{msh}[] fns = file("evalProg.json");
type femFunction{fns} func = file("evalProg.json");
input msh a;
input fns b = fns(a);
input func c = func(b);
input real zeroEps = 0.00000000001;
input real intervalEps = 0.00000000001;



real camDist = |camAt - camEye|;
real camNearVsp = camNear + camDist; 
real camFarVsp = camFar + camDist;   
vec3 camN = normalize(camAt - camEye); // away
vec3 camU = normalize(camN × camUp);    // right
vec3 camV = camU × camN;                // up
real camVmax = tan(camFOV*π/360)*camDist;
real camUmax = camVmax*iresU/iresV;



input int[] indecies;//[2][10][10]
input vec2[] times;//intervals
input int[] cells;//cell indecies
//color:
input vec3 mcnear ("material color at near clipping plane (for depth cuing)") = [1,1,1];
input vec3 mcfar ("material color at far clipping plane") = [1,1,1];
input image(1)[3] cmap ("univariate colormap") = load_image("/home/teocollin/gitcode/diderot/tests/lipRay/find/cmap.nrrd");
input real cmin ("value mapped to min end of colormap") = 0.0;
input real cmax ("value mapped to max end of colormap. By default cmin==cmax==0, which disables this colormapping") = 1.0;
field#0(1)[3] CM = tent ⊛ clamp(cmap);
//light:
input bool light = false;
input real phongKa ("Blinn-Phong ambient component") = 0.5;
input real phongKd ("Blinn-Phong diffuse component") = 0.5;
input real phongKs ("Blinn-Phong specular component") = 0.0;
input real phongSp ("Blinn-Phong specularity exponent") = 60;
input real maxAlpha ("maximum opacity on rendered surface") = 1;
input vec3 lightVsp = [0,3.69,1.53];//[0.0, 0.0, 1.0]; // light direction in view-space
vec3 L = transpose([camU,camV,camN])•normalize(lightVsp);

input bool debug = false;
input int debugU = 8;
input int debugV = 2;


function int sign(real x){
  if (x > 0.0) {return(1);}
  else if (x < 0.0){return(-1);}
  else {return(0);}
}

strand ray(int ui, int vi){
  real rayU = lerp(-camUmax, camUmax, -0.5, ui, iresU-0.5);       
  real rayV = lerp(-camVmax, camVmax, -0.5, vi, iresV-0.5);
  vec3 UV = rayU*camU + rayV*camV;
  
  vec3 rayOrig = camEye + UV;
  vec3 rayVec = camN + [0,0,0]; 
  real camNearVsp = camNearVsp;
  real camFarVsp = camFarVsp;
  vec3 rayStart = rayOrig + camNearVsp * rayVec;
  int offset = indecies[ui * iresV + vi];//indecies[0][ui][vi];
  int len = indecies[iresU*iresV + ui * iresV + vi ];//indecies[1][ui][vi];
  int itter = 0;
  int intersectionItter = 0;
  int idx = offset + itter;
  vec2 interval = times[idx];
  real s = interval[0];
  real e = interval[1];
  cell{msh} cc = a.cells[0];
  cell{func} fc = (c.funcCell)(cc);
  bool newton = true;
  output real out = 0;
  output vec4 rgba = [0,0,0,0];
  output vec3[] locs = {};

  start{
    if (debug && (ui != debugU) && (vi != debugV)){stabilize;}
    if(len == 0){ print("(find:)No intersection found:", ui, "/", vi, "\n");stabilize;}
    cc = a.cells[cells[idx]];
    fc = c.funcCell(cc);
  } 
  
  update {
    print("Ui/Vi::", ui, "/", vi, "\n");
    print("Interval:", [s,e],"\n");
    print("inner itter:",intersectionItter,"\n");
    print("Outer itter:",itter,"\n");
    vec2 startRay = [rayOrig[0], rayOrig[1]] + s * [rayVec[0], rayVec[1]];
    vec2 endRay = [rayOrig[0], rayOrig[1]] + e * [rayVec[0], rayVec[1]];
    vec2 invertA = cc.inverseTransform(startRay);
    vec2 invertB = cc.inverseTransform(endRay);
    print("inverses:", invertA, invertB,"\n");
    real faVal = fc.refField(invertA);
    real fa = faVal - rayVec[2]*s - rayOrig[2];
    real fb = fc.refField(invertB) - rayVec[2]*e - rayOrig[2];
    print("Vals:",[fa,fb],"\n");
    if (|fa - fb| < intervalEps && |fa| > intervalEps && |fb| > intervalEps){
      print("warn\n");
      s+=intervalEps;
      continue;
    }
    real cup = (s* fb - e*fa)/(fb -fa);
    print("Mid time:", cup, "\n");
    vec2 midRay = [rayOrig[0], rayOrig[1]] +  cup * [rayVec[0], rayVec[1]];
    vec2 invertC = cc.inverseTransform(midRay);
    real fmVal = fc.refField(invertC);
    real fm = fmVal - rayVec[2]* cup  - rayOrig[2];
    print("all vals:",[fa, fm, fb],"\n");
    intersectionItter+=1;
    if (sign(fa)* sign(fm) < 0){
      e = cup;

    }
    else if (sign(fa)* sign(fm) > 0)
      {
	s = cup;
      }
    print("new interval:", [s,e],"\n");
    //I think |fa| < eps and |fb| < eps are impossible... but double check
    if (|fm| < zeroEps ){
      vec2 grad = [0,0];
      vec3 loc = rayOrig;
      if (|fm| < zeroEps){
	grad = ∇ ( fc.refField ∘ cc.inverseTransform)(midRay);
	out = fmVal;
      }
      print("Out val:",out,"\n");
      print("Grad val:",grad,"\n");
      vec3 mcol = [1,1,1];
      if (cmin != cmax){
	mcol = CM(lerp(-1, 1, cmin, out, cmax));
      }
      if(light){
	vec3 N = normalize([grad[0], grad[1], -1]);
	vec3 H = normalize(-normalize(rayVec)+L);
	vec3 lightColor = lerp(mcnear, mcfar, camNearVsp, cup, camFarVsp);
	  
	vec3 ambientTerm = phongKa * mcol;
	vec3 diffuse = phongKd * modulate(mcol,lightColor)*max(0,N•L);
	vec3 specular = phongKs*lightColor*((max(0,N•H))^phongSp);
	vec3 fin = ambientTerm + diffuse + specular;
	rgba = [fin[0],fin[1],fin[2],1];
      } else {
	rgba = [mcol[0],mcol[1],mcol[2],1];
      }
      locs = {rayVec * cup + rayOrig};
      stabilize;
    }
    if (intersectionItter > 32){
      intersectionItter = 0;
      itter+=1;
      if(itter >= len){print("No intersection found\n");print("Fin pixel=============================\n");stabilize;}
      interval = times[offset+itter]; cc = a.cells[cells[offset + itter]];
      s = interval[0]; e = interval[1];
      fc = c.funcCell(cc);
      print("++++++++++++++++Next interval!+++++++++++++++++++\n");
      continue;
    }
    else
      {print("---------------\n");}
    
    

    
  }
    
    
} create_array {ray(ui,vi) | vi in 0..iresU-1, ui in 0..iresV-1};
