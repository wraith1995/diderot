#version 3.0

type mesh msh = file("test1.json");
/* type functionSpace{msh}[] fns = file("test1.json"); */
/* type femFunction{fns} FUNC = file("test1.json"); */

input msh a;
/* input fns b = fns(a); */      
/* input FUNC c = FUNC(b); */



input int iresU ("# samples on horizontal axis of image") = 50;
input int iresV ("# samples on vertical axis of image") = 50;
input int debugU = 3;
input int debugV = 0;
input bool debug = true;

input vec3 camEye = [0.5, -0.5, 0.5];
input vec3 camAt = [1.0,0.5,1.0];
input vec3 camUp = [0,0,1.0];

input real camFOV ("Vertical angle subtended by image") = 15;
input real rayStep ("Sampling distance on central ray") = 0.1;
input real camNear = -1;
input real camFar = 1;

vec3 camN = normalize(camAt-camEye);     
vec3 camU = normalize(camN × camUp);
vec3 camV = camN × camU;


real camDist = |camAt - camEye|;
real camNearVsp = camNear + camDist; 
real camFarVsp = camFar + camDist;   
real camVmax = tan(camFOV*π/360)*camDist;
real camUmax = camVmax*iresU/iresV;
input real eps = 0.00000001;

strand ray(int ui, int vi) {
  real rayU = lerp(-camUmax, camUmax, -0.5, ui, iresU-0.5);       
  real rayV = lerp(-camVmax, camVmax, -0.5, vi, iresV-0.5);
  vec3 UV = rayU*camU + rayV*camV;
  
  vec3 rayOrig = camEye + UV;
  vec3 rayVec = camN + [0,0,0]; 

  vec3 rayStart = rayOrig + camNearVsp * rayVec;
  vec3 rayEnd = rayOrig + camFarVsp * rayVec;
  vec3 dpos = rayEnd - rayStart;
  output cell{msh}[] cells = {};
  output real[] normalizedTimes = {};
  output real aaaa = 0;

  output int cellIntersects = 0;

  output vec2[] rayCellInter = {};
  output tensor[3][] spaceInter = {};
  output cell{msh}[] cellInter = {};
  int currentCellInt = -1;
  real startRayTime = 0;
  real saveStartRayTime = 0;
  cell{msh} currentCell = a.cells[0];
  int steps = 0;

  position{msh} pos = a.invalidPos();
  start {
    real startTime = 1.0;
    if ((ui != debugU || vi != debugV) && debug){
      stabilize;
    }
    foreach (cell{msh} c in a.cells())
      {
	real newTime = c.enter(rayStart, dpos);
	if (newTime >= 0.0 && 1.0 > newTime){
	  real newRayTime = lerp(camNearVsp,camFarVsp, newTime);
	  normalizedTimes = normalizedTimes@newRayTime;
	  cells = cells@c;
	  if (startTime > newTime){startTime  = newTime; currentCellInt = cellIntersects;}
	  cellIntersects+=1;
	}
	
      }
    print("Cells:",cells,"\n");

    if (cellIntersects != 0){
      currentCell = cells[currentCellInt];
      //cellInter = cellInter@currentCell;
      startRayTime = normalizedTimes[currentCellInt] + eps;
      print("times:", normalizedTimes, " int:", currentCellInt, "\n");
      rayCellInter = rayCellInter@[camNearVsp, startRayTime];
      spaceInter = spaceInter@{rayStart, rayOrig + rayVec*startRayTime};
      print(spaceInter,"\n");
      //print("Start time:", startRayTime, "\n");
      //print("First':", rayOrig + rayVec*startRayTime, "\n");
    } else {
      print("No intersection!\n");
      stabilize;}
  }


  update {
    steps+=1;
    vec3 startPos = rayOrig + startRayTime * rayVec;
    bool needsRecalc = !(pos.isValid());
    if (needsRecalc){
      vec3 refPos = nan[3];
    if ((currentCell.isInside(startPos))){
      refPos = currentCell.inverseTransform(startPos);
      pos = currentCell.meshPos(refPos);
    } else {
      vec3 startPos' = rayOrig + (startRayTime-eps) * rayVec;
      vec3 startPos'' = rayOrig + (startRayTime+eps) * rayVec;
      if (currentCell.isInside(startPos')){
	refPos = currentCell.inverseTransform(startPos');
	startPos = startPos';
	pos = currentCell.meshPos(refPos);
      }
      else if (currentCell.isInside(startPos'')){
	startPos = startPos'';
	refPos = currentCell.inverseTransform(startPos'');
	pos = currentCell.meshPos(refPos);
      }
      else{print("Error occured!\n"); stabilize;}
    }}
    vec3 newDpos = camFarVsp * rayVec;      
    real nextTime = pos.exit(newDpos);
    real endRayTime = max(startRayTime, min(camFarVsp, lerp(startRayTime, camFarVsp, nextTime)));
    print("Next time:", nextTime, "\n");
    print("cell ",currentCell, " and transform dofs:", currentCell.transformDofs,"\n");
    if (nextTime > 0){
      rayCellInter = rayCellInter@[startRayTime, endRayTime];
      startRayTime = endRayTime;
      vec3 endPos = rayOrig + (endRayTime) * rayVec;
      
      position{msh} pos' = pos.exitPos(newDpos);
      print("Adding pos:", endPos, "\n");
      spaceInter = spaceInter@endPos;
      cellInter = cellInter@currentCell;
      if (endRayTime == camFarVsp){stabilize;}
      print("validity:", pos'.isValid, "\n");
      pos = pos';
      if (pos.isValid()){
	currentCell = pos.mc();
	print("Moved to cell:",currentCell,"\n");
	print("Continue\n");
	continue;
      }
    }
    print("Continuing on\n");
    pos = a.invalidPos();
    int newIdx = -1;
    print("The end ray time is ", endRayTime, "\n");
    foreach (int i in 0..(cellIntersects)){
      real t = normalizedTimes[i];
      if (t > endRayTime){
	print("The new time is ", t, "\n");
	newIdx = i;
      }
    }
    if (newIdx > -1){
      print("Impossible happened\n\n");
      currentCell = cells[newIdx];
      startRayTime = normalizedTimes[newIdx];
      continue;
    } else { print(cellInter, "\n"); print(rayCellInter, "\n");print(spaceInter,"\n");stabilize;}
      
      /* print("Error occured:",nextTime,"\n"); */
      /* print("Started  with:",saveStartRayTime, "\n"); */
      /* print("Took ",steps, " steps\n"); */
      /* print("First':", rayOrig + rayVec*saveStartRayTime, "\n"); */
      /* print("Pixels:", ui," ", vi, "\n"); */
      /* if (steps == 0){ print("Pixel to examine!\n");} */
      /* print("\n"); */
      /* stabilize; */

  }
} create_array {ray(ui,vi) | vi in 0..iresU-1, ui in 0..iresV-1};
