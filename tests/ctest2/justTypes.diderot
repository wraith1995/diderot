#version 3.0
type mesh msh = file("test1.json");
type functionSpace{msh}[] fns = file("test1.json");
type femFunction{fns} FUNC = file("test1.json");

input msh a;
input fns b = fns(a);      
input FUNC c = FUNC(b);
field(3)[] V = c.F;
input real isoval = 0.2;  input real thick = 0.07;
input vec3 camEye = [3.0,-3.0,3.0];  input vec3 camAt = [0.5,0.5,0.5];   input vec3 camUp = [0,0,1];
input real camFOV = 13.7;  input int iresU = 500;    input int iresV = 500;
input real camNear = -2; input real camFar = 5; // NOTE: missing from paper: sloppy code condensing
input real refStep = 1.0; input real rayStep =0.01;
input vec3 lightVsp = [0.0, 0.0, 1.0]; // light direction in view-space
input real phongKa = 0.1; input real phongKd = 0.9;

input bool debug = false;
input int su = 250;
input int sv = 250;

//field#4(3)[] V = bspln5 ⊛ image("vol.nrrd"); // NOTE: paper had different filename
field#4(3)[] F = V - isoval; // isosurface is {x|F(x)=0}
function real mask(vec3 x) = 1.0;
image(1)[3] I = load_image("cmap.nrrd");
field#0(1)[3] cmap = tent ⊛ clamp(I); // NOTE: paper had different filename
function vec3 color(vec3 x) = cmap(V(x));
function real alpha(real v, real g)
  = clamp(0, 1, 1.3*(1 - |v|/(g*thick)));

real camDist = |camAt - camEye|;
vec3 camN = normalize(camAt - camEye); // away
vec3 camU = normalize(camN × camUp);    // right
vec3 camV = camU × camN;                // up
real camVmax = tan(camFOV*π/360)*camDist;
real camUmax = camVmax*iresU/iresV;
vec3 light = transpose([camU,camV,camN])•normalize(lightVsp);

strand raycast (int ui, int vi) {
  real rayU = lerp(-camUmax, camUmax, -0.5, ui, iresU-0.5);
  real rayV = lerp(camVmax, -camVmax, -0.5, vi, iresV-0.5);
  real rayN = camNear;
  vec3 rayVec = camN + (rayU*camU + rayV*camV)/camDist;
  real transp = 1;
  vec3 rgb = [0, 0, 0];
  output vec4 rgba = [0, 0, 0, 0];
  output real gray = 0;

  update {
       if (debug){
	if (ui != su || vi != sv){
	  stabilize;
	}
       }
       vec3 x = camEye + rayN*rayVec;
       //print("Hey:", x, val, grad,"\n");
       if (0.0 < x[0] && x[0] < 1.0 && 0.0 < x[1] && x[1] < 1.0 && 0.0 < x[2] && x[2] < 1.0)
	 {
	   position{msh} p = a.findPos(x);
	   if (p.isValid()) {
	     real val = F(x);
	     vec3 grad = -∇F(x);
	     real a = alpha(val, |grad|)*mask(x);
	     if (a > 0) {
	       a = 1 - pow(1-a, rayStep*|rayVec|/refStep);
	       real depth = lerp(1.1, 0.7, camNear, rayN, camFar);
	       real shade = max(0, normalize(grad)•light);
	       rgb += transp*a*depth*(phongKa + phongKd*shade)*color(x);
	       transp *= 1 - a;
	     }
	     print("yay!\n");
	   }
	   else {
	     print(x, "\n");
	     print("wait what?\n");
	   }
	 }
      
    if (transp < 0.01) {  // early ray termination
      transp = 0;
      stabilize;
    }
    if (rayN > camFar) stabilize;
    rayN = rayN + rayStep;
  }
  stabilize {
    real a = 1 - transp; // undo pre-multiplied alpha
    if (a > 0) rgba = [rgb[0]/a, rgb[1]/a, rgb[2]/a, a];
    if (ui == su && vi == sv && debug){
      print(a, rgba);
    }
  }
}
create_array {raycast(ui, vi) | vi in 0..iresV-1, ui in 0..iresU-1};
