/* ParseTree: After parsing */
  Program @ [15.diderot:3.1-15.1] 
    [
      Input: atest= @ [15.diderot:3.1-4.0] 
        Cons @ [15.diderot:3.26-63] 
          [
            Lit: 0 @ [15.diderot:3.27-28] 
            Lit: 1 @ [15.diderot:3.29-30] 
            Lit: 2 @ [15.diderot:3.31-32] 
            Lit: 3 @ [15.diderot:3.33-34] 
            Lit: 4 @ [15.diderot:3.35-36] 
            Lit: 5 @ [15.diderot:3.37-38] 
            Lit: 6 @ [15.diderot:3.39-40] 
            Lit: 8 @ [15.diderot:3.41-42] 
            Lit: 9 @ [15.diderot:3.43-44] 
            Lit: 10 @ [15.diderot:3.45-47] 
            Lit: 11 @ [15.diderot:3.48-50] 
            Lit: 12 @ [15.diderot:3.51-53] 
            Lit: 13 @ [15.diderot:3.54-56] 
            Lit: 14 @ [15.diderot:3.57-59] 
            Lit: 15 @ [15.diderot:3.60-62] 
          ]
      Var @ [15.diderot:4.1-5.0] 
        Decl: a= @ [15.diderot:4.1-5.0] 
          Sequence @ [15.diderot:4.11-14] 
            [
              Lit: 1 @ [15.diderot:4.12-13] 
            ]
    ]
    Strand: gg @ [15.diderot:5.1-14.3] 
      [
        Param: i @ [15.diderot:5.11-16] 
          Int @ [15.diderot:5.11-15] 
      ]
      [
        VarDcl: output @ [15.diderot:6.3-7.0] 
        VarDcl: output @ [15.diderot:7.3-8.0] 
      ]
      [
        Method: Update @ [15.diderot:9.3-14.1] 
          Block @ [15.diderot:9.9-14.0] 
            [
              Assign: temp= @ [15.diderot:10.5-11.0] 
                BinOp: • @ [15.diderot:10.12-23] 
                  Var: umm @ [15.diderot:10.12-15] 
                  Var: umm @ [15.diderot:10.20-23] 
              Print @ [15.diderot:11.5-12.0] 
                [
                  Var: temp @ [15.diderot:11.11-15] 
                ]
              Stabilize @ [15.diderot:12.5-13.0] 
            ]
      ]
    Collection @ [15.diderot:14.3-15.1] 
      Comprehension @ [15.diderot:14.21-15.0] 
        Apply @ [15.diderot:14.22-27] 
          Var: gg @ [15.diderot:14.22-24] 
          [
            Var: j @ [15.diderot:14.25-26] 
          ]
        [
          Iterator: j @ [15.diderot:14.30-36] 
            Var: a @ [15.diderot:14.35-36] 
        ]
/* end program */
/* AST: After typechecking */
properties: HasInputs,HasGlobals
input tensor[15] atest = [0.e0, 0.1e1, 0.2e1, 0.3e1, 0.4e1, 0.5e1, 0.6e1, 0.8e1, 0.9e1, 0.1e2, 0.11e2, 0.12e2, 0.13e2, 0.14e2, 0.15e2];
int[] a = (int[]){1};
strand gg (int i)
{
  output tensor[15] umm = atest;
  output real temp = 0.e0;
  update {
    temp = •<$[15]; $[15]; $[]> (umm, umm);
    print (temp);
    stabilize;
    }
  
}
collection {
    foreach (int j in a) {
      new gg (j);
      }
    }
  
/* Program end */
/* Simplified Program (after after simplify) start */
properties: GlobalInit,HasInputs,HasGlobals
input tensor[15] atest01C6 = <default>;
constants {
  real _t01C7 = 0.e0;
  real _t01C8 = 0.1e1;
  real _t01C9 = 0.2e1;
  real _t01CA = 0.3e1;
  real _t01CB = 0.4e1;
  real _t01CC = 0.5e1;
  real _t01CD = 0.6e1;
  real _t01CE = 0.8e1;
  real _t01CF = 0.9e1;
  real _t01D0 = 0.1e2;
  real _t01D1 = 0.11e2;
  real _t01D2 = 0.12e2;
  real _t01D3 = 0.13e2;
  real _t01D4 = 0.14e2;
  real _t01D5 = 0.15e2;
  atest01C6 = [_t01C7, _t01C8, _t01C9, _t01CA, _t01CB, _t01CC, _t01CD, _t01CE, _t01CF, _t01D0, _t01D1, _t01D2, _t01D3, _t01D4, _t01D5];
}
global int[] a01D9;
globalInit {
  int _t01D6 = 1;
  int[1] _t01D7 = {_t01D6};
  int[] _t01D8 = (int[])_t01D7;
  a01D9 = _t01D8;
}
strand gg (int i01DA) {
  output tensor[15] umm01DB;
  output real temp01DC;
  {
    umm01DB = atest01C6;
    temp01DC = 0.e0;
  }
  update
  {
    temp01DC = •00CE<$[15]; $[15]; $[]> (umm01DB, umm01DB);
    print (temp01DC);
    stabilize;
  }
}
collection {
  foreach j01DD in a01D9 {
    new gg (j01DD);
  }
}
/* Program end */
/* Simplified Program (after after contraction (1)) start */
properties: GlobalInit,HasInputs,HasGlobals
input tensor[15] atest01C6 = <default>;
constants {
  real _t01C7 = 0.e0;
  real _t01C8 = 0.1e1;
  real _t01C9 = 0.2e1;
  real _t01CA = 0.3e1;
  real _t01CB = 0.4e1;
  real _t01CC = 0.5e1;
  real _t01CD = 0.6e1;
  real _t01CE = 0.8e1;
  real _t01CF = 0.9e1;
  real _t01D0 = 0.1e2;
  real _t01D1 = 0.11e2;
  real _t01D2 = 0.12e2;
  real _t01D3 = 0.13e2;
  real _t01D4 = 0.14e2;
  real _t01D5 = 0.15e2;
  atest01C6 = [_t01C7, _t01C8, _t01C9, _t01CA, _t01CB, _t01CC, _t01CD, _t01CE, _t01CF, _t01D0, _t01D1, _t01D2, _t01D3, _t01D4, _t01D5];
}
global int[] a01D9;
globalInit {
  int _t01D6 = 1;
  int[1] _t01D7 = {_t01D6};
  int[] _t01D8 = (int[])_t01D7;
  a01D9 = _t01D8;
}
strand gg (int i01DA) {
  output tensor[15] umm01DB;
  output real temp01DC;
  {
    umm01DB = atest01C6;
    temp01DC = 0.e0;
  }
  update
  {
    temp01DC = •00CE<$[15]; $[15]; $[]> (umm01DB, umm01DB);
    print (temp01DC);
    stabilize;
  }
}
collection {
  foreach j01DD in a01D9 {
    new gg (j01DD);
  }
}
/* Program end */
/* Simplified Program (after after map-reduce-fusion) start */
properties: GlobalInit,HasInputs,HasGlobals
input tensor[15] atest01C6 = <default>;
constants {
  real _t01C7 = 0.e0;
  real _t01C8 = 0.1e1;
  real _t01C9 = 0.2e1;
  real _t01CA = 0.3e1;
  real _t01CB = 0.4e1;
  real _t01CC = 0.5e1;
  real _t01CD = 0.6e1;
  real _t01CE = 0.8e1;
  real _t01CF = 0.9e1;
  real _t01D0 = 0.1e2;
  real _t01D1 = 0.11e2;
  real _t01D2 = 0.12e2;
  real _t01D3 = 0.13e2;
  real _t01D4 = 0.14e2;
  real _t01D5 = 0.15e2;
  atest01C6 = [_t01C7, _t01C8, _t01C9, _t01CA, _t01CB, _t01CC, _t01CD, _t01CE, _t01CF, _t01D0, _t01D1, _t01D2, _t01D3, _t01D4, _t01D5];
}
global int[] a01D9;
globalInit {
  int _t01D6 = 1;
  int[1] _t01D7 = {_t01D6};
  int[] _t01D8 = (int[])_t01D7;
  a01D9 = _t01D8;
}
strand gg (int i01DA) {
  output tensor[15] umm01DB;
  output real temp01DC;
  {
    umm01DB = atest01C6;
    temp01DC = 0.e0;
  }
  update
  {
    temp01DC = •00CE<$[15]; $[15]; $[]> (umm01DB, umm01DB);
    print (temp01DC);
    stabilize;
  }
}
collection {
  foreach j01DD in a01D9 {
    new gg (j01DD);
  }
}
/* Program end */
/* Simplified Program (after after inlining) start */
properties: GlobalInit,HasInputs,HasGlobals
input tensor[15] atest01C6 = <default>;
constants {
  real _t01C7 = 0.e0;
  real _t01C8 = 0.1e1;
  real _t01C9 = 0.2e1;
  real _t01CA = 0.3e1;
  real _t01CB = 0.4e1;
  real _t01CC = 0.5e1;
  real _t01CD = 0.6e1;
  real _t01CE = 0.8e1;
  real _t01CF = 0.9e1;
  real _t01D0 = 0.1e2;
  real _t01D1 = 0.11e2;
  real _t01D2 = 0.12e2;
  real _t01D3 = 0.13e2;
  real _t01D4 = 0.14e2;
  real _t01D5 = 0.15e2;
  atest01C6 = [_t01C7, _t01C8, _t01C9, _t01CA, _t01CB, _t01CC, _t01CD, _t01CE, _t01CF, _t01D0, _t01D1, _t01D2, _t01D3, _t01D4, _t01D5];
}
global int[] a01D9;
globalInit {
  int _t01D6 = 1;
  int[1] _t01D7 = {_t01D6};
  int[] _t01D8 = (int[])_t01D7;
  a01D9 = _t01D8;
}
strand gg (int i01DA) {
  output tensor[15] umm01DB;
  output real temp01DC;
  {
    umm01DB = atest01C6;
    temp01DC = 0.e0;
  }
  update
  {
    temp01DC = •00CE<$[15]; $[15]; $[]> (umm01DB, umm01DB);
    print (temp01DC);
    stabilize;
  }
}
collection {
  foreach j01DD in a01D9 {
    new gg (j01DD);
  }
}
/* Program end */
/* Simplified Program (after after contraction (2)) start */
properties: GlobalInit,HasInputs,HasGlobals
input tensor[15] atest01C6 = <default>;
constants {
  real _t01C7 = 0.e0;
  real _t01C8 = 0.1e1;
  real _t01C9 = 0.2e1;
  real _t01CA = 0.3e1;
  real _t01CB = 0.4e1;
  real _t01CC = 0.5e1;
  real _t01CD = 0.6e1;
  real _t01CE = 0.8e1;
  real _t01CF = 0.9e1;
  real _t01D0 = 0.1e2;
  real _t01D1 = 0.11e2;
  real _t01D2 = 0.12e2;
  real _t01D3 = 0.13e2;
  real _t01D4 = 0.14e2;
  real _t01D5 = 0.15e2;
  atest01C6 = [_t01C7, _t01C8, _t01C9, _t01CA, _t01CB, _t01CC, _t01CD, _t01CE, _t01CF, _t01D0, _t01D1, _t01D2, _t01D3, _t01D4, _t01D5];
}
global int[] a01D9;
globalInit {
  int _t01D6 = 1;
  int[1] _t01D7 = {_t01D6};
  int[] _t01D8 = (int[])_t01D7;
  a01D9 = _t01D8;
}
strand gg (int i01DA) {
  output tensor[15] umm01DB;
  output real temp01DC;
  {
    umm01DB = atest01C6;
    temp01DC = 0.e0;
  }
  update
  {
    temp01DC = •00CE<$[15]; $[15]; $[]> (umm01DB, umm01DB);
    print (temp01DC);
    stabilize;
  }
}
collection {
  foreach j01DD in a01D9 {
    new gg (j01DD);
  }
}
/* Program end */
/* Simplified Program (after after simplify fields) start */
properties: GlobalInit,HasInputs,HasGlobals
input tensor[15] atest01C6 = <default>;
constants {
  real _t01C7 = 0.e0;
  real _t01C8 = 0.1e1;
  real _t01C9 = 0.2e1;
  real _t01CA = 0.3e1;
  real _t01CB = 0.4e1;
  real _t01CC = 0.5e1;
  real _t01CD = 0.6e1;
  real _t01CE = 0.8e1;
  real _t01CF = 0.9e1;
  real _t01D0 = 0.1e2;
  real _t01D1 = 0.11e2;
  real _t01D2 = 0.12e2;
  real _t01D3 = 0.13e2;
  real _t01D4 = 0.14e2;
  real _t01D5 = 0.15e2;
  atest01C6 = [_t01C7, _t01C8, _t01C9, _t01CA, _t01CB, _t01CC, _t01CD, _t01CE, _t01CF, _t01D0, _t01D1, _t01D2, _t01D3, _t01D4, _t01D5];
}
global int[] a01D9;
globalInit {
  int _t01D6 = 1;
  int[1] _t01D7 = {_t01D6};
  int[] _t01D8 = (int[])_t01D7;
  a01D9 = _t01D8;
}
strand gg (int i01DA) {
  output tensor[15] umm01DB;
  output real temp01DC;
  {
    umm01DB = atest01C6;
    temp01DC = 0.e0;
  }
  update
  {
    temp01DC = •00CE<$[15]; $[15]; $[]> (umm01DB, umm01DB);
    print (temp01DC);
    stabilize;
  }
}
collection {
  foreach j01DD in a01D9 {
    new gg (j01DD);
  }
}
/* Program end */
/* Simplified Program (after after simplify variables) start */
properties: GlobalInit,HasInputs,HasGlobals
input tensor[15] atest01C6 = <default>;
constants {
  real _t01C7 = 0.e0;
  real _t01C8 = 0.1e1;
  real _t01C9 = 0.2e1;
  real _t01CA = 0.3e1;
  real _t01CB = 0.4e1;
  real _t01CC = 0.5e1;
  real _t01CD = 0.6e1;
  real _t01CE = 0.8e1;
  real _t01CF = 0.9e1;
  real _t01D0 = 0.1e2;
  real _t01D1 = 0.11e2;
  real _t01D2 = 0.12e2;
  real _t01D3 = 0.13e2;
  real _t01D4 = 0.14e2;
  real _t01D5 = 0.15e2;
  atest01C6 = [_t01C7, _t01C8, _t01C9, _t01CA, _t01CB, _t01CC, _t01CD, _t01CE, _t01CF, _t01D0, _t01D1, _t01D2, _t01D3, _t01D4, _t01D5];
}
global int[] a01D9;
globalInit {
  int _t01D6 = 1;
  int[1] _t01D7 = {_t01D6};
  int[] _t01D8 = (int[])_t01D7;
  a01D9 = _t01D8;
}
strand gg (int i01DA) {
  output tensor[15] umm01DB;
  output real temp01DC;
  {
    umm01DB = atest01C6;
    temp01DC = 0.e0;
  }
  update
  {
    temp01DC = •00CE<$[15]; $[15]; $[]> (umm01DB, umm01DB);
    print (temp01DC);
    stabilize;
  }
}
collection {
  foreach j01DD in a01D9 {
    new gg (j01DD);
  }
}
/* Program end */
##### high-ir: after simple-to-high translation ####
## properties
  GlobalInit HasInputs HasGlobals
## globals
  input atest01DE (atest) = <default>
  global int[] a0202
## functions
## input initialization
  ENTRY0200:  preds = []
    real _t01DF#1 = 0.e0;
    real _t01E1#1 = 0.1e1;
    real _t01E3#1 = 0.2e1;
    real _t01E5#1 = 0.3e1;
    real _t01E7#1 = 0.4e1;
    real _t01E9#1 = 0.5e1;
    real _t01EB#1 = 0.6e1;
    real _t01ED#1 = 0.8e1;
    real _t01EF#1 = 0.9e1;
    real _t01F1#1 = 0.1e2;
    real _t01F3#1 = 0.11e2;
    real _t01F5#1 = 0.12e2;
    real _t01F7#1 = 0.13e2;
    real _t01F9#1 = 0.14e2;
    real _t01FB#1 = 0.15e2;
    tensor[15] atest01FD#1 = <tensor[15]>[_t01DF,_t01E1,_t01E3,_t01E5,_t01E7,_t01E9,_t01EB,_t01ED,_t01EF,_t01F1,_t01F3,_t01F5,_t01F7,_t01F9,_t01FB];
    globals.atest01DE = atest01FD;
    return
## global-variable initialization
  ENTRY020C:  preds = []
    int _t0203#1 = 1;
    int[1] _t0205#1 = <int[1]>{_t0203};
    int[] _t0207#1 = MkDynamic<int,1>(_t0205);
    int[] a0209#1 = _t0207;
    globals.a0202 = a0209;
    return
## strand
  strand gg (int i0216#0)
    state:
      output tensor[15] umm;
      output real temp;
    state init
      ENTRY0221:  preds = []
        tensor[15] atest0219#1 = globals.atest01DE;
        tensor[15] umm021D#1 = atest0219;
        real temp021F#1 = 0.e0;
        self.umm = umm021D;
        self.temp = temp021F;
        return
    end state init
    method update
        ENTRY022E:  preds = []
          tensor[15] umm0225#2 = self.umm;
          real temp0226#0 = self.temp;
          real temp0229#2 = λ(T0[15],T1[15])<Σ(i0=0..14)<((T0_{i0} * T1_{i0}))>(i0=0..14)> (umm0225,umm0225);
          Print<[real]>(temp0229);
          self.temp = temp0229;
          stabilize
    end update
  end gg
## initial strand creation
  COLLECTION
    ENTRY0214:  preds = []
      int[] a020E#1 = globals.a0202;
    FOREACH0211:  preds = [ASSIGN020F,NEXT0213]
      foreach (j0210 in a020E) on exit goto RETURN0215
      new gg(j0210);
      goto FOREACH0211
    RETURN0215:  preds = [FOREACH0211]
      return
#### end program ####
##### high-ir: after value numbering ####
## properties
  GlobalInit HasInputs HasGlobals
## globals
  input atest01DE (atest) = <default>
  global int[] a0202
## functions
## input initialization
  ENTRY0200:  preds = []
    real _t01DF#1 = 0.e0;
    real _t01E1#1 = 0.1e1;
    real _t01E3#1 = 0.2e1;
    real _t01E5#1 = 0.3e1;
    real _t01E7#1 = 0.4e1;
    real _t01E9#1 = 0.5e1;
    real _t01EB#1 = 0.6e1;
    real _t01ED#1 = 0.8e1;
    real _t01EF#1 = 0.9e1;
    real _t01F1#1 = 0.1e2;
    real _t01F3#1 = 0.11e2;
    real _t01F5#1 = 0.12e2;
    real _t01F7#1 = 0.13e2;
    real _t01F9#1 = 0.14e2;
    real _t01FB#1 = 0.15e2;
    tensor[15] atest01FD#1 = <tensor[15]>[_t01DF,_t01E1,_t01E3,_t01E5,_t01E7,_t01E9,_t01EB,_t01ED,_t01EF,_t01F1,_t01F3,_t01F5,_t01F7,_t01F9,_t01FB];
    globals.atest01DE = atest01FD;
    return
## global-variable initialization
  ENTRY020C:  preds = []
    int _t0203#1 = 1;
    int[1] _t0205#1 = <int[1]>{_t0203};
    int[] _t0207#1 = MkDynamic<int,1>(_t0205);
    globals.a0202 = _t0207;
    return
## strand
  strand gg (int i0216#0)
    state:
      output tensor[15] umm;
      output real temp;
    state init
      ENTRY0221:  preds = []
        tensor[15] atest0219#1 = globals.atest01DE;
        real temp021F#1 = 0.e0;
        self.umm = atest0219;
        self.temp = temp021F;
        return
    end state init
    method update
        ENTRY022E:  preds = []
          tensor[15] umm0225#2 = self.umm;
          real temp0226#0 = self.temp;
          real temp0229#2 = λ(T0[15],T1[15])<Σ(i0=0..14)<((T0_{i0} * T1_{i0}))>(i0=0..14)> (umm0225,umm0225);
          Print<[real]>(temp0229);
          self.temp = temp0229;
          stabilize
    end update
  end gg
## initial strand creation
  COLLECTION
    ENTRY0214:  preds = []
      int[] a020E#1 = globals.a0202;
    FOREACH0211:  preds = [ASSIGN020F,NEXT0213]
      foreach (j0210 in a020E) on exit goto RETURN0215
      new gg(j0210);
      goto FOREACH0211
    RETURN0215:  preds = [FOREACH0211]
      return
#### end program ####
##### high-ir: after normalization rewriting ####
## properties
  GlobalInit HasInputs HasGlobals
## globals
  input atest01DE (atest) = <default>
  global int[] a0202
## functions
## input initialization
  ENTRY0200:  preds = []
    real _t01DF#1 = 0.e0;
    real _t01E1#1 = 0.1e1;
    real _t01E3#1 = 0.2e1;
    real _t01E5#1 = 0.3e1;
    real _t01E7#1 = 0.4e1;
    real _t01E9#1 = 0.5e1;
    real _t01EB#1 = 0.6e1;
    real _t01ED#1 = 0.8e1;
    real _t01EF#1 = 0.9e1;
    real _t01F1#1 = 0.1e2;
    real _t01F3#1 = 0.11e2;
    real _t01F5#1 = 0.12e2;
    real _t01F7#1 = 0.13e2;
    real _t01F9#1 = 0.14e2;
    real _t01FB#1 = 0.15e2;
    tensor[15] atest01FD#1 = <tensor[15]>[_t01DF,_t01E1,_t01E3,_t01E5,_t01E7,_t01E9,_t01EB,_t01ED,_t01EF,_t01F1,_t01F3,_t01F5,_t01F7,_t01F9,_t01FB];
    globals.atest01DE = atest01FD;
    return
## global-variable initialization
  ENTRY020C:  preds = []
    int _t0203#1 = 1;
    int[1] _t0205#1 = <int[1]>{_t0203};
    int[] _t0207#1 = MkDynamic<int,1>(_t0205);
    globals.a0202 = _t0207;
    return
## strand
  strand gg (int i0216#0)
    state:
      output tensor[15] umm;
      output real temp;
    state init
      ENTRY0221:  preds = []
        tensor[15] atest0219#1 = globals.atest01DE;
        real temp021F#1 = 0.e0;
        self.umm = atest0219;
        self.temp = temp021F;
        return
    end state init
    method update
        ENTRY022E:  preds = []
          tensor[15] umm0225#2 = self.umm;
          real temp0229#2 = λ(T0[15],T1[15])<Σ(i0=0..14)<((T0_{i0} * T1_{i0}))>(i0=0..14)> (umm0225,umm0225);
          Print<[real]>(temp0229);
          self.temp = temp0229;
          stabilize
    end update
  end gg
## initial strand creation
  COLLECTION
    ENTRY0214:  preds = []
      int[] a020E#1 = globals.a0202;
    FOREACH0211:  preds = [ASSIGN020F,NEXT0213]
      foreach (j0210 in a020E) on exit goto RETURN0215
      new gg(j0210);
      goto FOREACH0211
    RETURN0215:  preds = [FOREACH0211]
      return
#### end program ####
##### high-ir: after normalization promotion ####
## properties
  GlobalInit HasInputs HasGlobals
## globals
  input atest01DE (atest) = <default>
  global int[] a0202
## functions
## input initialization
  ENTRY0200:  preds = []
    real _t01DF#1 = 0.e0;
    real _t01E1#1 = 0.1e1;
    real _t01E3#1 = 0.2e1;
    real _t01E5#1 = 0.3e1;
    real _t01E7#1 = 0.4e1;
    real _t01E9#1 = 0.5e1;
    real _t01EB#1 = 0.6e1;
    real _t01ED#1 = 0.8e1;
    real _t01EF#1 = 0.9e1;
    real _t01F1#1 = 0.1e2;
    real _t01F3#1 = 0.11e2;
    real _t01F5#1 = 0.12e2;
    real _t01F7#1 = 0.13e2;
    real _t01F9#1 = 0.14e2;
    real _t01FB#1 = 0.15e2;
    tensor[15] atest01FD#1 = <tensor[15]>[_t01DF,_t01E1,_t01E3,_t01E5,_t01E7,_t01E9,_t01EB,_t01ED,_t01EF,_t01F1,_t01F3,_t01F5,_t01F7,_t01F9,_t01FB];
    globals.atest01DE = atest01FD;
    return
## global-variable initialization
  ENTRY020C:  preds = []
    int _t0203#1 = 1;
    int[1] _t0205#1 = <int[1]>{_t0203};
    int[] _t0207#1 = MkDynamic<int,1>(_t0205);
    globals.a0202 = _t0207;
    return
## strand
  strand gg (int i0216#0)
    state:
      output tensor[15] umm;
      output real temp;
    state init
      ENTRY0221:  preds = []
        tensor[15] atest0219#1 = globals.atest01DE;
        real temp021F#1 = 0.e0;
        self.umm = atest0219;
        self.temp = temp021F;
        return
    end state init
    method update
        ENTRY022E:  preds = []
          tensor[15] umm0225#2 = self.umm;
          real temp0229#2 = λ(T0[15],T1[15])<Σ(i0=0..14)<((T0_{i0} * T1_{i0}))>(i0=0..14)> (umm0225,umm0225);
          Print<[real]>(temp0229);
          self.temp = temp0229;
          stabilize
    end update
  end gg
## initial strand creation
  COLLECTION
    ENTRY0214:  preds = []
      int[] a020E#1 = globals.a0202;
    FOREACH0211:  preds = [ASSIGN020F,NEXT0213]
      foreach (j0210 in a020E) on exit goto RETURN0215
      new gg(j0210);
      goto FOREACH0211
    RETURN0215:  preds = [FOREACH0211]
      return
#### end program ####
##### mid-ir: after high-to-mid translation ####
## properties
  GlobalInit HasInputs HasGlobals
## globals
  input atest0232 (atest) = <default>
  global int[] a0233
## functions
## input initialization
  ENTRY0234:  preds = []
    real _t0235#1 = 0.e0;
    real _t0237#1 = 0.1e1;
    real _t0239#1 = 0.2e1;
    real _t023B#1 = 0.3e1;
    real _t023D#1 = 0.4e1;
    real _t023F#1 = 0.5e1;
    real _t0241#1 = 0.6e1;
    real _t0243#1 = 0.8e1;
    real _t0245#1 = 0.9e1;
    real _t0247#1 = 0.1e2;
    real _t0249#1 = 0.11e2;
    real _t024B#1 = 0.12e2;
    real _t024D#1 = 0.13e2;
    real _t024F#1 = 0.14e2;
    real _t0251#1 = 0.15e2;
    tensor[15] atest0253#1 = <tensor[15]>[_t0235,_t0237,_t0239,_t023B,_t023D,_t023F,_t0241,_t0243,_t0245,_t0247,_t0249,_t024B,_t024D,_t024F,_t0251];
    globals.atest0232 = atest0253;
    return
## global-variable initialization
  ENTRY0257:  preds = []
    int _t0258#1 = 1;
    int[1] _t025A#1 = <int[1]>{_t0258};
    int[] _t025C#1 = MkDynamic<int,1>(_t025A);
    globals.a0233 = _t025C;
    return
## strand
  strand gg (int i0260#0)
    state:
      output tensor[15] umm;
      output real temp;
    state init
      ENTRY0263:  preds = []
        tensor[15] atest0264#1 = globals.atest0232;
        real temp0266#1 = 0.e0;
        self.umm = atest0264;
        self.temp = temp0266;
        return
    end state init
    method update
        ENTRY026B:  preds = []
          tensor[15] umm026C#2 = self.umm;
          real temp026E#2 = λ(T0[15],T1[15])<Σ(i0=0..14)<((T0_{i0} * T1_{i0}))>(i0=0..14)> (umm026C,umm026C);
          Print<[real]>(temp026E);
          self.temp = temp026E;
          stabilize
    end update
  end gg
## initial strand creation
  COLLECTION
    ENTRY0274:  preds = []
      int[] a0275#1 = globals.a0233;
    FOREACH0278:  preds = [ASSIGN0276,NEXT027A]
      foreach (j0277 in a0275) on exit goto RETURN027B
      new gg(j0277);
      goto FOREACH0278
    RETURN027B:  preds = [FOREACH0278]
      return
#### end program ####
##### mid-ir: after value numbering ####
## properties
  GlobalInit HasInputs HasGlobals
## globals
  input atest0232 (atest) = <default>
  global int[] a0233
## functions
## input initialization
  ENTRY0234:  preds = []
    real _t0235#1 = 0.e0;
    real _t0237#1 = 0.1e1;
    real _t0239#1 = 0.2e1;
    real _t023B#1 = 0.3e1;
    real _t023D#1 = 0.4e1;
    real _t023F#1 = 0.5e1;
    real _t0241#1 = 0.6e1;
    real _t0243#1 = 0.8e1;
    real _t0245#1 = 0.9e1;
    real _t0247#1 = 0.1e2;
    real _t0249#1 = 0.11e2;
    real _t024B#1 = 0.12e2;
    real _t024D#1 = 0.13e2;
    real _t024F#1 = 0.14e2;
    real _t0251#1 = 0.15e2;
    tensor[15] atest0253#1 = <tensor[15]>[_t0235,_t0237,_t0239,_t023B,_t023D,_t023F,_t0241,_t0243,_t0245,_t0247,_t0249,_t024B,_t024D,_t024F,_t0251];
    globals.atest0232 = atest0253;
    return
## global-variable initialization
  ENTRY0257:  preds = []
    int _t0258#1 = 1;
    int[1] _t025A#1 = <int[1]>{_t0258};
    int[] _t025C#1 = MkDynamic<int,1>(_t025A);
    globals.a0233 = _t025C;
    return
## strand
  strand gg (int i0260#0)
    state:
      output tensor[15] umm;
      output real temp;
    state init
      ENTRY0263:  preds = []
        tensor[15] atest0264#1 = globals.atest0232;
        real temp0266#1 = 0.e0;
        self.umm = atest0264;
        self.temp = temp0266;
        return
    end state init
    method update
        ENTRY026B:  preds = []
          tensor[15] umm026C#2 = self.umm;
          real temp026E#2 = λ(T0[15],T1[15])<Σ(i0=0..14)<((T0_{i0} * T1_{i0}))>(i0=0..14)> (umm026C,umm026C);
          Print<[real]>(temp026E);
          self.temp = temp026E;
          stabilize
    end update
  end gg
## initial strand creation
  COLLECTION
    ENTRY0274:  preds = []
      int[] a0275#1 = globals.a0233;
    FOREACH0278:  preds = [ASSIGN0276,NEXT027A]
      foreach (j0277 in a0275) on exit goto RETURN027B
      new gg(j0277);
      goto FOREACH0278
    RETURN027B:  preds = [FOREACH0278]
      return
#### end program ####
##### mid-ir: after contraction ####
## properties
  GlobalInit HasInputs HasGlobals
## globals
  input atest0232 (atest) = <default>
  global int[] a0233
## functions
## input initialization
  ENTRY0234:  preds = []
    real _t0235#1 = 0.e0;
    real _t0237#1 = 0.1e1;
    real _t0239#1 = 0.2e1;
    real _t023B#1 = 0.3e1;
    real _t023D#1 = 0.4e1;
    real _t023F#1 = 0.5e1;
    real _t0241#1 = 0.6e1;
    real _t0243#1 = 0.8e1;
    real _t0245#1 = 0.9e1;
    real _t0247#1 = 0.1e2;
    real _t0249#1 = 0.11e2;
    real _t024B#1 = 0.12e2;
    real _t024D#1 = 0.13e2;
    real _t024F#1 = 0.14e2;
    real _t0251#1 = 0.15e2;
    tensor[15] atest0253#1 = <tensor[15]>[_t0235,_t0237,_t0239,_t023B,_t023D,_t023F,_t0241,_t0243,_t0245,_t0247,_t0249,_t024B,_t024D,_t024F,_t0251];
    globals.atest0232 = atest0253;
    return
## global-variable initialization
  ENTRY0257:  preds = []
    int _t0258#1 = 1;
    int[1] _t025A#1 = <int[1]>{_t0258};
    int[] _t025C#1 = MkDynamic<int,1>(_t025A);
    globals.a0233 = _t025C;
    return
## strand
  strand gg (int i0260#0)
    state:
      output tensor[15] umm;
      output real temp;
    state init
      ENTRY0263:  preds = []
        tensor[15] atest0264#1 = globals.atest0232;
        real temp0266#1 = 0.e0;
        self.umm = atest0264;
        self.temp = temp0266;
        return
    end state init
    method update
        ENTRY026B:  preds = []
          tensor[15] umm026C#2 = self.umm;
          real temp026E#2 = λ(T0[15],T1[15])<Σ(i0=0..14)<((T0_{i0} * T1_{i0}))>(i0=0..14)> (umm026C,umm026C);
          Print<[real]>(temp026E);
          self.temp = temp026E;
          stabilize
    end update
  end gg
## initial strand creation
  COLLECTION
    ENTRY0274:  preds = []
      int[] a0275#1 = globals.a0233;
    FOREACH0278:  preds = [ASSIGN0276,NEXT027A]
      foreach (j0277 in a0275) on exit goto RETURN027B
      new gg(j0277);
      goto FOREACH0278
    RETURN027B:  preds = [FOREACH0278]
      return
#### end program ####
##### mid-ir: after border control ####
## properties
  GlobalInit HasInputs HasGlobals
## globals
  input atest0232 (atest) = <default>
  global int[] a0233
## functions
## input initialization
  ENTRY0234:  preds = []
    real _t0235#1 = 0.e0;
    real _t0237#1 = 0.1e1;
    real _t0239#1 = 0.2e1;
    real _t023B#1 = 0.3e1;
    real _t023D#1 = 0.4e1;
    real _t023F#1 = 0.5e1;
    real _t0241#1 = 0.6e1;
    real _t0243#1 = 0.8e1;
    real _t0245#1 = 0.9e1;
    real _t0247#1 = 0.1e2;
    real _t0249#1 = 0.11e2;
    real _t024B#1 = 0.12e2;
    real _t024D#1 = 0.13e2;
    real _t024F#1 = 0.14e2;
    real _t0251#1 = 0.15e2;
    tensor[15] atest0253#1 = <tensor[15]>[_t0235,_t0237,_t0239,_t023B,_t023D,_t023F,_t0241,_t0243,_t0245,_t0247,_t0249,_t024B,_t024D,_t024F,_t0251];
    globals.atest0232 = atest0253;
    return
## global-variable initialization
  ENTRY0257:  preds = []
    int _t0258#1 = 1;
    int[1] _t025A#1 = <int[1]>{_t0258};
    int[] _t025C#1 = MkDynamic<int,1>(_t025A);
    globals.a0233 = _t025C;
    return
## strand
  strand gg (int i0260#0)
    state:
      output tensor[15] umm;
      output real temp;
    state init
      ENTRY0263:  preds = []
        tensor[15] atest0264#1 = globals.atest0232;
        real temp0266#1 = 0.e0;
        self.umm = atest0264;
        self.temp = temp0266;
        return
    end state init
    method update
        ENTRY026B:  preds = []
          tensor[15] umm026C#2 = self.umm;
          real temp026E#2 = λ(T0[15],T1[15])<Σ(i0=0..14)<((T0_{i0} * T1_{i0}))>(i0=0..14)> (umm026C,umm026C);
          Print<[real]>(temp026E);
          self.temp = temp026E;
          stabilize
    end update
  end gg
## initial strand creation
  COLLECTION
    ENTRY0274:  preds = []
      int[] a0275#1 = globals.a0233;
    FOREACH0278:  preds = [ASSIGN0276,NEXT027A]
      foreach (j0277 in a0275) on exit goto RETURN027B
      new gg(j0277);
      goto FOREACH0278
    RETURN027B:  preds = [FOREACH0278]
      return
#### end program ####
##### low-ir: after mid-to-low translation ####
## properties
  GlobalInit HasInputs HasGlobals
## globals
  input atest027C (atest) = <default>
  global int[] a027D
## functions
## input initialization
  ENTRY027E:  preds = []
    real _t027F#1 = 0.e0;
    real _t0281#1 = 0.1e1;
    real _t0283#1 = 0.2e1;
    real _t0285#1 = 0.3e1;
    real _t0287#1 = 0.4e1;
    real _t0289#1 = 0.5e1;
    real _t028B#1 = 0.6e1;
    real _t028D#1 = 0.8e1;
    real _t028F#1 = 0.9e1;
    real _t0291#1 = 0.1e2;
    real _t0293#1 = 0.11e2;
    real _t0295#1 = 0.12e2;
    real _t0297#1 = 0.13e2;
    real _t0299#1 = 0.14e2;
    real _t029B#1 = 0.15e2;
    tensor[15] atest029D#1 = <tensor[15]>[_t027F,_t0281,_t0283,_t0285,_t0287,_t0289,_t028B,_t028D,_t028F,_t0291,_t0293,_t0295,_t0297,_t0299,_t029B];
    globals.atest027C = atest029D;
    return
## global-variable initialization
  ENTRY02A1:  preds = []
    int _t02A2#1 = 1;
    int[1] _t02A4#1 = <int[1]>{_t02A2};
    int[] _t02A6#1 = MkDynamic<int,1>(_t02A4);
    globals.a027D = _t02A6;
    return
## strand
  strand gg (int i02AA#0)
    state:
      output tensor[15] umm;
      output real temp;
    state init
      ENTRY02AD:  preds = []
        tensor[15] atest02AE#1 = globals.atest027C;
        real temp02B0#1 = 0.e0;
        self.umm = atest02AE;
        self.temp = temp02B0;
        return
    end state init
    method update
        ENTRY02B5:  preds = []
          tensor[15] umm02B6#2 = self.umm;
          real temp02B8#2 = VDot<15>(umm02B6,umm02B6);
          Print<[real]>(temp02B8);
          self.temp = temp02B8;
          stabilize
    end update
  end gg
## initial strand creation
  COLLECTION
    ENTRY02BF:  preds = []
      int[] a02C0#1 = globals.a027D;
    FOREACH02C3:  preds = [ASSIGN02C1,NEXT02C5]
      foreach (j02C2 in a02C0) on exit goto RETURN02C6
      new gg(j02C2);
      goto FOREACH02C3
    RETURN02C6:  preds = [FOREACH02C3]
      return
#### end program ####
##### low-ir: after contraction(1) ####
## properties
  GlobalInit HasInputs HasGlobals
## globals
  input atest027C (atest) = <default>
  global int[] a027D
## functions
## input initialization
  ENTRY027E:  preds = []
    real _t027F#1 = 0.e0;
    real _t0281#1 = 0.1e1;
    real _t0283#1 = 0.2e1;
    real _t0285#1 = 0.3e1;
    real _t0287#1 = 0.4e1;
    real _t0289#1 = 0.5e1;
    real _t028B#1 = 0.6e1;
    real _t028D#1 = 0.8e1;
    real _t028F#1 = 0.9e1;
    real _t0291#1 = 0.1e2;
    real _t0293#1 = 0.11e2;
    real _t0295#1 = 0.12e2;
    real _t0297#1 = 0.13e2;
    real _t0299#1 = 0.14e2;
    real _t029B#1 = 0.15e2;
    tensor[15] atest029D#1 = <tensor[15]>[_t027F,_t0281,_t0283,_t0285,_t0287,_t0289,_t028B,_t028D,_t028F,_t0291,_t0293,_t0295,_t0297,_t0299,_t029B];
    globals.atest027C = atest029D;
    return
## global-variable initialization
  ENTRY02A1:  preds = []
    int _t02A2#1 = 1;
    int[1] _t02A4#1 = <int[1]>{_t02A2};
    int[] _t02A6#1 = MkDynamic<int,1>(_t02A4);
    globals.a027D = _t02A6;
    return
## strand
  strand gg (int i02AA#0)
    state:
      output tensor[15] umm;
      output real temp;
    state init
      ENTRY02AD:  preds = []
        tensor[15] atest02AE#1 = globals.atest027C;
        real temp02B0#1 = 0.e0;
        self.umm = atest02AE;
        self.temp = temp02B0;
        return
    end state init
    method update
        ENTRY02B5:  preds = []
          tensor[15] umm02B6#2 = self.umm;
          real temp02B8#2 = VDot<15>(umm02B6,umm02B6);
          Print<[real]>(temp02B8);
          self.temp = temp02B8;
          stabilize
    end update
  end gg
## initial strand creation
  COLLECTION
    ENTRY02BF:  preds = []
      int[] a02C0#1 = globals.a027D;
    FOREACH02C3:  preds = [ASSIGN02C1,NEXT02C5]
      foreach (j02C2 in a02C0) on exit goto RETURN02C6
      new gg(j02C2);
      goto FOREACH02C3
    RETURN02C6:  preds = [FOREACH02C3]
      return
#### end program ####
##### low-ir: after value numbering ####
## properties
  GlobalInit HasInputs HasGlobals
## globals
  input atest027C (atest) = <default>
  global int[] a027D
## functions
## input initialization
  ENTRY027E:  preds = []
    real _t027F#1 = 0.e0;
    real _t0281#1 = 0.1e1;
    real _t0283#1 = 0.2e1;
    real _t0285#1 = 0.3e1;
    real _t0287#1 = 0.4e1;
    real _t0289#1 = 0.5e1;
    real _t028B#1 = 0.6e1;
    real _t028D#1 = 0.8e1;
    real _t028F#1 = 0.9e1;
    real _t0291#1 = 0.1e2;
    real _t0293#1 = 0.11e2;
    real _t0295#1 = 0.12e2;
    real _t0297#1 = 0.13e2;
    real _t0299#1 = 0.14e2;
    real _t029B#1 = 0.15e2;
    tensor[15] atest029D#1 = <tensor[15]>[_t027F,_t0281,_t0283,_t0285,_t0287,_t0289,_t028B,_t028D,_t028F,_t0291,_t0293,_t0295,_t0297,_t0299,_t029B];
    globals.atest027C = atest029D;
    return
## global-variable initialization
  ENTRY02A1:  preds = []
    int _t02A2#1 = 1;
    int[1] _t02A4#1 = <int[1]>{_t02A2};
    int[] _t02A6#1 = MkDynamic<int,1>(_t02A4);
    globals.a027D = _t02A6;
    return
## strand
  strand gg (int i02AA#0)
    state:
      output tensor[15] umm;
      output real temp;
    state init
      ENTRY02AD:  preds = []
        tensor[15] atest02AE#1 = globals.atest027C;
        real temp02B0#1 = 0.e0;
        self.umm = atest02AE;
        self.temp = temp02B0;
        return
    end state init
    method update
        ENTRY02B5:  preds = []
          tensor[15] umm02B6#2 = self.umm;
          real temp02B8#2 = VDot<15>(umm02B6,umm02B6);
          Print<[real]>(temp02B8);
          self.temp = temp02B8;
          stabilize
    end update
  end gg
## initial strand creation
  COLLECTION
    ENTRY02BF:  preds = []
      int[] a02C0#1 = globals.a027D;
    FOREACH02C3:  preds = [ASSIGN02C1,NEXT02C5]
      foreach (j02C2 in a02C0) on exit goto RETURN02C6
      new gg(j02C2);
      goto FOREACH02C3
    RETURN02C6:  preds = [FOREACH02C3]
      return
#### end program ####
##### low-ir: after contraction(2) ####
## properties
  GlobalInit HasInputs HasGlobals
## globals
  input atest027C (atest) = <default>
  global int[] a027D
## functions
## input initialization
  ENTRY027E:  preds = []
    real _t027F#1 = 0.e0;
    real _t0281#1 = 0.1e1;
    real _t0283#1 = 0.2e1;
    real _t0285#1 = 0.3e1;
    real _t0287#1 = 0.4e1;
    real _t0289#1 = 0.5e1;
    real _t028B#1 = 0.6e1;
    real _t028D#1 = 0.8e1;
    real _t028F#1 = 0.9e1;
    real _t0291#1 = 0.1e2;
    real _t0293#1 = 0.11e2;
    real _t0295#1 = 0.12e2;
    real _t0297#1 = 0.13e2;
    real _t0299#1 = 0.14e2;
    real _t029B#1 = 0.15e2;
    tensor[15] atest029D#1 = <tensor[15]>[_t027F,_t0281,_t0283,_t0285,_t0287,_t0289,_t028B,_t028D,_t028F,_t0291,_t0293,_t0295,_t0297,_t0299,_t029B];
    globals.atest027C = atest029D;
    return
## global-variable initialization
  ENTRY02A1:  preds = []
    int _t02A2#1 = 1;
    int[1] _t02A4#1 = <int[1]>{_t02A2};
    int[] _t02A6#1 = MkDynamic<int,1>(_t02A4);
    globals.a027D = _t02A6;
    return
## strand
  strand gg (int i02AA#0)
    state:
      output tensor[15] umm;
      output real temp;
    state init
      ENTRY02AD:  preds = []
        tensor[15] atest02AE#1 = globals.atest027C;
        real temp02B0#1 = 0.e0;
        self.umm = atest02AE;
        self.temp = temp02B0;
        return
    end state init
    method update
        ENTRY02B5:  preds = []
          tensor[15] umm02B6#2 = self.umm;
          real temp02B8#2 = VDot<15>(umm02B6,umm02B6);
          Print<[real]>(temp02B8);
          self.temp = temp02B8;
          stabilize
    end update
  end gg
## initial strand creation
  COLLECTION
    ENTRY02BF:  preds = []
      int[] a02C0#1 = globals.a027D;
    FOREACH02C3:  preds = [ASSIGN02C1,NEXT02C5]
      foreach (j02C2 in a02C0) on exit goto RETURN02C6
      new gg(j02C2);
      goto FOREACH02C3
    RETURN02C6:  preds = [FOREACH02C3]
      return
#### end program ####
##### low-ir: after flatten ####
## properties
  GlobalInit HasInputs HasGlobals
## globals
  input atest027C (atest) = <default>
  global int[] a027D
## functions
## input initialization
  ENTRY027E:  preds = []
    real _t027F#1 = 0.e0;
    real _t0281#1 = 0.1e1;
    real _t0283#1 = 0.2e1;
    real _t0285#1 = 0.3e1;
    real _t0287#1 = 0.4e1;
    real _t0289#1 = 0.5e1;
    real _t028B#1 = 0.6e1;
    real _t028D#1 = 0.8e1;
    real _t028F#1 = 0.9e1;
    real _t0291#1 = 0.1e2;
    real _t0293#1 = 0.11e2;
    real _t0295#1 = 0.12e2;
    real _t0297#1 = 0.13e2;
    real _t0299#1 = 0.14e2;
    real _t029B#1 = 0.15e2;
    tensor[15] atest029D#1 = <tensor[15]>[_t027F,_t0281,_t0283,_t0285,_t0287,_t0289,_t028B,_t028D,_t028F,_t0291,_t0293,_t0295,_t0297,_t0299,_t029B];
    globals.atest027C = atest029D;
    return
## global-variable initialization
  ENTRY02A1:  preds = []
    int _t02A2#1 = 1;
    int[1] _t02A4#1 = <int[1]>{_t02A2};
    int[] _t02A6#1 = MkDynamic<int,1>(_t02A4);
    globals.a027D = _t02A6;
    return
## strand
  strand gg (int i02AA#0)
    state:
      output tensor[15] umm;
      output real temp;
    state init
      ENTRY02AD:  preds = []
        tensor[15] atest02AE#1 = globals.atest027C;
        real temp02B0#1 = 0.e0;
        self.umm = atest02AE;
        self.temp = temp02B0;
        return
    end state init
    method update
        ENTRY02B5:  preds = []
          tensor[15] umm02B6#2 = self.umm;
          real temp02B8#2 = VDot<15>(umm02B6,umm02B6);
          Print<[real]>(temp02B8);
          self.temp = temp02B8;
          stabilize
    end update
  end gg
## initial strand creation
  COLLECTION
    ENTRY02BF:  preds = []
      int[] a02C0#1 = globals.a027D;
    FOREACH02C3:  preds = [ASSIGN02C1,NEXT02C5]
      foreach (j02C2 in a02C0) on exit goto RETURN02C6
      new gg(j02C2);
      goto FOREACH02C3
    RETURN02C6:  preds = [FOREACH02C3]
      return
#### end program ####
##### TreeIR: after low-to-tree translation ####
//***** PROPERTIES *****
  GlobalInit HasInputs HasGlobals
//***** CONSTS *****
//***** INPUTS *****
input tensor[15] atest;
//***** CONST INIT *****
  {
    globals.atest = PACK(VEC8(0.e0,0.1e1,0.2e1,0.3e1,0.4e1,0.5e1,0.6e1,0.8e1),VEC7{8}(0.9e1,0.1e2,0.11e2,0.12e2,0.13e2,0.14e2,0.15e2));
  }
//***** GLOBALS *****
global int[] a;
//***** FUNCTIONS *****
//***** GLOBAL VARIABLE INIT *****
  {
    int[1] t_2 = <int[1]>{1};
    int[] l__t_1 = MkDynamic<int,1>(t_2);
    globals.a = l__t_1;
  }
//***** STRAND *****
strand gg (int p_i_3) {
  output tensor[15] umm;
  varying output real temp;
  initialize (globals) {
    self.umm = TensorCopy<[15]>(TensorRef<[15]>(globals.atest));
    self.temp = 0.e0;
  }
  update (world) {
    real l_temp_4 = RAdd(VDot<7,8>(LOAD_1(TensorRef<[15]>(self.umm)),LOAD_1(TensorRef<[15]>(self.umm))),VDot<8,8>(LOAD_0(TensorRef<[15]>(self.umm)),LOAD_0(TensorRef<[15]>(self.umm))));
    print(l_temp_4);
    self.temp = l_temp_4;
    stabilize;
  }
}
//***** CREATE COLLECTION *****
  {
    foreach int i_j_5 in globals.a {
      new gg(i_j_5);
    }
  }
#### end program ####
##### TreeIR: after contraction ####
//***** PROPERTIES *****
  GlobalInit HasInputs HasGlobals
//***** CONSTS *****
//***** INPUTS *****
input tensor[15] atest;
//***** CONST INIT *****
  {
    globals.atest = <tensor[15]>[0.e0,0.1e1,0.2e1,0.3e1,0.4e1,0.5e1,0.6e1,0.8e1,0.9e1,0.1e2,0.11e2,0.12e2,0.13e2,0.14e2,0.15e2];
  }
//***** GLOBALS *****
global int[] a;
//***** FUNCTIONS *****
//***** GLOBAL VARIABLE INIT *****
  {
    int[1] t_2 = <int[1]>{1};
    int[] l__t_1 = MkDynamic<int,1>(t_2);
    globals.a = l__t_1;
  }
//***** STRAND *****
strand gg (int p_i_3) {
  output tensor[15] umm;
  varying output real temp;
  initialize (globals) {
    self.umm = TensorCopy<[15]>(TensorRef<[15]>(globals.atest));
    self.temp = 0.e0;
  }
  update (world) {
    real l_temp_4 = RAdd(VDot<7,8>(LOAD_1(TensorRef<[15]>(self.umm)),LOAD_1(TensorRef<[15]>(self.umm))),VDot<8,8>(LOAD_0(TensorRef<[15]>(self.umm)),LOAD_0(TensorRef<[15]>(self.umm))));
    print(l_temp_4);
    self.temp = l_temp_4;
    stabilize;
  }
}
//***** CREATE COLLECTION *****
  {
    foreach int i_j_5 in globals.a {
      new gg(i_j_5);
    }
  }
#### end program ####
/usr/bin/clang++ -fPIC -m64 -c -Wreturn-type -Wuninitialized -march=native -O3 -DNDEBUG -mavx2 -msse4.2 -I/home/teocollin/installs/diderot/diderot/include -I/home/teocollin/installs/teem/teem-build/include 15.cxx
