/* ParseTree: After parsing */
  Program @ [crap.diderot:3.1-40.0] 
    [
      Type: ff= @ [crap.diderot:3.1-4.0] 
        Int @ [crap.diderot:3.6-10] 
        From File : ffint.json @ [crap.diderot:3.1-4.0] 
      Const: l= @ [crap.diderot:4.1-5.0] 
        Select @ [crap.diderot:4.15-22] 
          Var: ff @ [crap.diderot:4.15-17] 
          ffff
      Const: ll= @ [crap.diderot:5.1-6.0] 
        Select @ [crap.diderot:5.19-26] 
          Var: ff @ [crap.diderot:5.19-21] 
          bunt
      Const: jam= @ [crap.diderot:6.1-7.0] 
        Subscript @ [crap.diderot:6.17-22] 
          Var: ll @ [crap.diderot:6.17-19] 
          [
            Lit: 0 @ [crap.diderot:6.20-21] 
          ]
      Var @ [crap.diderot:7.1-8.0] 
        Decl: a1= @ [crap.diderot:7.1-8.0] 
          SeqComp @ [crap.diderot:7.12-45] 
            Comprehension @ [crap.diderot:7.12-45] 
              BinOp: + @ [crap.diderot:7.13-19] 
                Var: k @ [crap.diderot:7.13-14] 
                Lit: 2 @ [crap.diderot:7.17-18] 
              [
                Iterator: k @ [crap.diderot:7.21-44] 
                  SeqComp @ [crap.diderot:7.26-44] 
                    Comprehension @ [crap.diderot:7.26-44] 
                      BinOp: + @ [crap.diderot:7.27-31] 
                        Lit: 1 @ [crap.diderot:7.27-28] 
                        Var: j @ [crap.diderot:7.29-30] 
                      [
                        Iterator: j @ [crap.diderot:7.33-43] 
                          Range @ [crap.diderot:7.38-43] 
                            Lit: 0 @ [crap.diderot:7.38-39] 
                            Lit: 10 @ [crap.diderot:7.41-43] 
                      ]
              ]
      Var @ [crap.diderot:8.1-9.0] 
        Decl: a3= @ [crap.diderot:8.1-9.0] 
          Sequence @ [crap.diderot:8.14-27] 
            [
              Apply @ [crap.diderot:8.15-20] 
                Var: ff @ [crap.diderot:8.15-17] 
                [
                  Lit: 0 @ [crap.diderot:8.18-19] 
                ]
              Apply @ [crap.diderot:8.21-26] 
                Var: ff @ [crap.diderot:8.21-23] 
                [
                  Lit: 1 @ [crap.diderot:8.24-25] 
                ]
            ]
      Var @ [crap.diderot:9.1-10.0] 
        Decl: a4= @ [crap.diderot:9.1-10.0] 
          Sequence @ [crap.diderot:9.12-25] 
            [
              Apply @ [crap.diderot:9.13-18] 
                Var: ff @ [crap.diderot:9.13-15] 
                [
                  Lit: 0 @ [crap.diderot:9.16-17] 
                ]
              Apply @ [crap.diderot:9.19-24] 
                Var: ff @ [crap.diderot:9.19-21] 
                [
                  Lit: 1 @ [crap.diderot:9.22-23] 
                ]
            ]
      Var @ [crap.diderot:10.1-11.0] 
        Decl: a5= @ [crap.diderot:10.1-11.0] 
          Sequence @ [crap.diderot:10.12-25] 
            [
              Apply @ [crap.diderot:10.13-18] 
                Var: ff @ [crap.diderot:10.13-15] 
                [
                  Lit: 0 @ [crap.diderot:10.16-17] 
                ]
              Apply @ [crap.diderot:10.19-24] 
                Var: ff @ [crap.diderot:10.19-21] 
                [
                  Lit: 1 @ [crap.diderot:10.22-23] 
                ]
            ]
      Var @ [crap.diderot:11.1-12.0] 
        Decl: a2= @ [crap.diderot:11.1-12.0] 
          SeqComp @ [crap.diderot:11.13-50] 
            Comprehension @ [crap.diderot:11.13-50] 
              BinOp: + @ [crap.diderot:11.14-22] 
                Var: k @ [crap.diderot:11.14-15] 
                Lit: 0.2e1 @ [crap.diderot:11.18-21] 
              [
                Iterator: k @ [crap.diderot:11.24-49] 
                  SeqComp @ [crap.diderot:11.29-49] 
                    Comprehension @ [crap.diderot:11.29-49] 
                      BinOp: + @ [crap.diderot:11.30-36] 
                        Lit: 0.1e1 @ [crap.diderot:11.30-33] 
                        Var: j @ [crap.diderot:11.34-35] 
                      [
                        Iterator: j @ [crap.diderot:11.38-48] 
                          Range @ [crap.diderot:11.43-48] 
                            Lit: 0 @ [crap.diderot:11.43-44] 
                            Lit: 10 @ [crap.diderot:11.46-48] 
                      ]
              ]
      Var @ [crap.diderot:12.1-13.0] 
        Decl: gad= @ [crap.diderot:12.1-13.0] 
          Cons @ [crap.diderot:12.20-65] 
            [
              Cons @ [crap.diderot:12.21-42] 
                [
                  Cons @ [crap.diderot:12.22-31] 
                    [
                      Lit: 0.e0 @ [crap.diderot:12.23-26] 
                      Lit: 0.e0 @ [crap.diderot:12.27-30] 
                    ]
                  Cons @ [crap.diderot:12.32-41] 
                    [
                      Lit: 0.e0 @ [crap.diderot:12.33-36] 
                      Lit: 0.e0 @ [crap.diderot:12.37-40] 
                    ]
                ]
              Cons @ [crap.diderot:12.43-64] 
                [
                  Cons @ [crap.diderot:12.44-53] 
                    [
                      Lit: 0.e0 @ [crap.diderot:12.45-48] 
                      Lit: 0.e0 @ [crap.diderot:12.49-52] 
                    ]
                  Cons @ [crap.diderot:12.54-63] 
                    [
                      Lit: 0.e0 @ [crap.diderot:12.55-58] 
                      Lit: 0.e0 @ [crap.diderot:12.59-62] 
                    ]
                ]
            ]
      Var @ [crap.diderot:13.1-14.0] 
        Decl: gad1= @ [crap.diderot:13.1-14.0] 
          Cons @ [crap.diderot:13.28-49] 
            [
              Cons @ [crap.diderot:13.29-38] 
                [
                  Lit: 0.e0 @ [crap.diderot:13.30-33] 
                  Lit: 0.e0 @ [crap.diderot:13.34-37] 
                ]
              Cons @ [crap.diderot:13.39-48] 
                [
                  Lit: 0.e0 @ [crap.diderot:13.40-43] 
                  Lit: 0.e0 @ [crap.diderot:13.44-47] 
                ]
            ]
      Func: f @ [crap.diderot:15.1-19.1] 
        Tensor @ [crap.diderot:15.10-15] 
          [ ]
        [
          Param: g @ [crap.diderot:15.17-23] 
            Tensor @ [crap.diderot:15.17-22] 
              [ ]
          Param: j @ [crap.diderot:15.25-30] 
            Int @ [crap.diderot:15.25-29] 
        ]
        Stmt @ [crap.diderot:15.1-19.1] 
          Return @ [crap.diderot:16.3-17.0] 
            BinOp: * @ [crap.diderot:16.10-13] 
              Var: g @ [crap.diderot:16.10-11] 
              Var: j @ [crap.diderot:16.12-13] 
      Func: s @ [crap.diderot:19.1-25.1] 
        Tensor @ [crap.diderot:19.10-15] 
          [ ]
        [
          Param: k @ [crap.diderot:19.17-23] 
            Tensor @ [crap.diderot:19.17-22] 
              [ ]
        ]
        Stmt @ [crap.diderot:19.1-25.1] 
          Block @ [crap.diderot:19.24-23.0] 
            [
              Print @ [crap.diderot:20.3-21.0] 
                [
                  Var: a1 @ [crap.diderot:20.9-11] 
                ]
              Return @ [crap.diderot:21.3-22.0] 
                Var: k @ [crap.diderot:21.10-11] 
            ]
    ]
    Strand: gg @ [crap.diderot:25.1-39.3] 
      [
        Param: i @ [crap.diderot:25.11-16] 
          Int @ [crap.diderot:25.11-15] 
        Param: j @ [crap.diderot:25.18-23] 
          Int @ [crap.diderot:25.18-22] 
      ]
      [
        VarDcl: output @ [crap.diderot:27.3-28.0] 
        VarDcl @ [crap.diderot:29.3-30.0] 
      ]
      [
        Method: Update @ [crap.diderot:31.3-39.1] 
          Block @ [crap.diderot:31.9-39.0] 
            [
              Assign: result= @ [crap.diderot:32.5-33.0] 
                Apply @ [crap.diderot:32.14-29] 
                  Var: f @ [crap.diderot:32.14-15] 
                  [
                    Var: result @ [crap.diderot:32.16-22] 
                    BinOp: * @ [crap.diderot:32.24-28] 
                      Var: i @ [crap.diderot:32.24-25] 
                      Lit: 10 @ [crap.diderot:32.26-28] 
                  ]
              Print @ [crap.diderot:33.5-34.0] 
                [
                  Subscript @ [crap.diderot:33.11-16] 
                    Var: ll @ [crap.diderot:33.11-13] 
                    [
                      Lit: 0 @ [crap.diderot:33.14-15] 
                    ]
                  Lit: " ! " @ [crap.diderot:33.17-22] 
                  Subscript @ [crap.diderot:33.24-29] 
                    Var: ll @ [crap.diderot:33.24-26] 
                    [
                      Lit: 1 @ [crap.diderot:33.27-28] 
                    ]
                  Lit: "bah\n" @ [crap.diderot:33.31-38] 
                ]
              Print @ [crap.diderot:34.5-35.0] 
                [
                  Var: result @ [crap.diderot:34.11-17] 
                  Lit: "\n" @ [crap.diderot:34.19-23] 
                  Lit: "numCell:" @ [crap.diderot:34.25-35] 
                  Lit: 2 @ [crap.diderot:34.37-38] 
                  Lit: "\n" @ [crap.diderot:34.40-44] 
                  Var: a1 @ [crap.diderot:34.46-48] 
                  Var: a2 @ [crap.diderot:34.49-51] 
                  Lit: "\n" @ [crap.diderot:34.53-57] 
                  Apply @ [crap.diderot:34.59-65] 
                    Var: s @ [crap.diderot:34.59-60] 
                    [
                      Lit: 0.2e1 @ [crap.diderot:34.61-64] 
                    ]
                  Lit: "\n" @ [crap.diderot:34.67-71] 
                  Var: j @ [crap.diderot:34.73-74] 
                  Lit: "\n" @ [crap.diderot:34.76-80] 
                ]
              Stabilize @ [crap.diderot:37.5-38.0] 
            ]
      ]
    Collection @ [crap.diderot:39.3-40.0] 
      Comprehension @ [crap.diderot:39.21-52] 
        Apply @ [crap.diderot:39.22-29] 
          Var: gg @ [crap.diderot:39.22-24] 
          [
            Var: j @ [crap.diderot:39.25-26] 
            Var: k @ [crap.diderot:39.27-28] 
          ]
        [
          Iterator: j @ [crap.diderot:39.32-39] 
            Var: a1 @ [crap.diderot:39.37-39] 
          Iterator: k @ [crap.diderot:39.41-51] 
            Range @ [crap.diderot:39.46-51] 
              Lit: 5 @ [crap.diderot:39.46-47] 
              Lit: 11 @ [crap.diderot:39.49-51] 
        ]
/* end program */
/* AST: After typechecking */
properties: HasGlobals,HasConsts
const int l = 2;
const int[2] ll = {2, 2};
const int jam = 2;
function int unpack (int arg0)
{
  return (int)arg0;
  }
function int ff (int arg0)
{
  return (ff( using int))arg0;
  }
int[] a1 = {+ (k, 2) | int k in {+ (1, j) | int j in $range (0, 10)}};
ff( using int)[2] a3 = {ff (0), ff (1)};
ff( using int)[2] a4 = {ff (0), ff (1)};
ff( using int)[2] a5 = {ff (0), ff (1)};
real[] a2 = {+<$[]> (k, 0.2e1) | real k in {+<$[]> (0.1e1, (real)j) | int j in $range (0, 10)}};
tensor[2,2,2] gad = [[[0.e0, 0.e0], [0.e0, 0.e0]], [[0.e0, 0.e0], [0.e0, 0.e0]]];
mat2 gad1 = [[0.e0, 0.e0], [0.e0, 0.e0]];
function real f (real g, int j)
{
  return * (g, (real)j);
  }
function real s (real k)
{
  print (a1);
  return k;
  }
strand gg (int i, int j)
{
  output real result = * (0.1e1, (real)i);
  int j0 = 2;
  update {
    result = f (result, * (i, 10));
    print ($sub<int; %2> (ll, 0), " ! ", $sub<int; %2> (ll, 1), "bah\n");
    print (result, "\n", "numCell:", 2, "\n", a1, a2, "\n", s (0.2e1), "\n", j, "\n");
    stabilize;
    }
  
}
collection {
    foreach (int j in a1) {
      foreach (int k in $range (5, 11)) {
        new gg (j, k);
        }
      }
    }
  
/* Program end */
/* Simplified Program (after after simplify) start */
properties: GlobalInit,HasGlobals,HasConsts
const int[2] ll022C;
constants {
  int _t022A = 2;
  int _t022B = 2;
  ll022C = {_t022A, _t022B};
}
global int[] a1023E;
global int[2] a30243;
global int[2] a40248;
global int[2] a5024D;
global real[] a2025A;
global tensor[2,2,2] gad0269;
global tensor[2,2] gad10270;
function int#0 unpack022D (int arg0022E)
{
  int _t022F = (int)arg0022E;
  return _t022F;
}
function int#6 ff0230 (int arg00231)
{
  int _t0232 = (int)arg00231;
  return _t0232;
}
function real#1 f0271 (real g0272, int j0273)
{
  real _t0274 = (real)j0273;
  real _t0275 = prim *0034 (g0272, _t0274);
  return _t0275;
}
function real#1 s0276 (real k0277)
{
  print (a1023E);
  return k0277;
}
globalInit {
  int _t0233 = 0;
  int _t0234 = 10;
  int[] _t0235 = prim $range01BF (_t0233, _t0234);
  int[] accum0239 = {};
  foreach j0237 in _t0235 {
    int _t0236 = 1;
    int _t0238 = prim +0015 (_t0236, j0237);
    accum0239 = prim @0010<int> (accum0239, _t0238);
  }
  int[] accum023D = {};
  foreach k023A in accum0239 {
    int _t023B = 2;
    int _t023C = prim +0015 (k023A, _t023B);
    accum023D = prim @0010<int> (accum023D, _t023C);
  }
  a1023E = accum023D;
  int _t023F = 0;
  int _t0240 = func ff0230 (_t023F);
  int _t0241 = 1;
  int _t0242 = func ff0230 (_t0241);
  a30243 = {_t0240, _t0242};
  int _t0244 = 0;
  int _t0245 = func ff0230 (_t0244);
  int _t0246 = 1;
  int _t0247 = func ff0230 (_t0246);
  a40248 = {_t0245, _t0247};
  int _t0249 = 0;
  int _t024A = func ff0230 (_t0249);
  int _t024B = 1;
  int _t024C = func ff0230 (_t024B);
  a5024D = {_t024A, _t024C};
  int _t024E = 0;
  int _t024F = 10;
  int[] _t0250 = prim $range01BF (_t024E, _t024F);
  real[] accum0255 = {};
  foreach j0252 in _t0250 {
    real _t0251 = 0.1e1;
    real _t0253 = (real)j0252;
    real _t0254 = prim +0017<$[]> (_t0251, _t0253);
    accum0255 = prim @0010<real> (accum0255, _t0254);
  }
  real[] accum0259 = {};
  foreach k0256 in accum0255 {
    real _t0257 = 0.2e1;
    real _t0258 = prim +0017<$[]> (k0256, _t0257);
    accum0259 = prim @0010<real> (accum0259, _t0258);
  }
  a2025A = accum0259;
  real _t025B = 0.e0;
  real _t025C = 0.e0;
  vec2 _t025D = [_t025B, _t025C];
  real _t025E = 0.e0;
  real _t025F = 0.e0;
  vec2 _t0260 = [_t025E, _t025F];
  tensor[2,2] _t0261 = [_t025D, _t0260];
  real _t0262 = 0.e0;
  real _t0263 = 0.e0;
  vec2 _t0264 = [_t0262, _t0263];
  real _t0265 = 0.e0;
  real _t0266 = 0.e0;
  vec2 _t0267 = [_t0265, _t0266];
  tensor[2,2] _t0268 = [_t0264, _t0267];
  gad0269 = [_t0261, _t0268];
  real _t026A = 0.e0;
  real _t026B = 0.e0;
  vec2 _t026C = [_t026A, _t026B];
  real _t026D = 0.e0;
  real _t026E = 0.e0;
  vec2 _t026F = [_t026D, _t026E];
  gad10270 = [_t026C, _t026F];
}
strand gg (int i0278, int j0279) {
  output real result027A;
  int j0027D;
  {
    real _t027B = 0.1e1;
    real _t027C = (real)i0278;
    result027A = prim *0034 (_t027B, _t027C);
    j0027D = 2;
  }
  update
  {
    int _t027E = 10;
    int _t027F = prim *0033 (i0278, _t027E);
    result027A = func f0271 (result027A, _t027F);
    int _t0280 = 0;
    int _t0281 = prim $sub01BC<int; %2> (ll022C, _t0280);
    string _t0282 = " ! ";
    int _t0283 = 1;
    int _t0284 = prim $sub01BC<int; %2> (ll022C, _t0283);
    string _t0285 = "bah\n";
    print (_t0281, _t0282, _t0284, _t0285);
    string _t0286 = "\n";
    string _t0287 = "numCell:";
    int _t0288 = 2;
    string _t0289 = "\n";
    string _t028A = "\n";
    real _t028B = 0.2e1;
    real _t028C = func s0276 (_t028B);
    string _t028D = "\n";
    string _t028E = "\n";
    print (result027A, _t0286, _t0287, _t0288, _t0289, a1023E, a2025A, _t028A, _t028C, _t028D, j0279, _t028E);
    stabilize;
  }
}
collection {
  foreach j0292 in a1023E {
    int _t028F = 5;
    int _t0290 = 11;
    int[] _t0291 = prim $range01BF (_t028F, _t0290);
    foreach k0293 in _t0291 {
      new gg (j0292, k0293);
    }
  }
}
/* Program end */
/* Simplified Program (after after contraction (1)) start */
properties: GlobalInit,HasGlobals,HasConsts
const int[2] ll022C;
constants {
  int _t022A = 2;
  int _t022B = 2;
  ll022C = {_t022A, _t022B};
}
global int[] a1023E;
global real[] a2025A;
function int#0 unpack022D (int arg0022E)
{
  int _t022F = (int)arg0022E;
  return _t022F;
}
function int#6 ff0230 (int arg00231)
{
  int _t0232 = (int)arg00231;
  return _t0232;
}
function real#1 f0271 (real g0272, int j0273)
{
  real _t0274 = (real)j0273;
  real _t0275 = prim *0034 (g0272, _t0274);
  return _t0275;
}
function real#1 s0276 (real k0277)
{
  print (a1023E);
  return k0277;
}
globalInit {
  int _t0233 = 0;
  int _t0234 = 10;
  int[] _t0235 = prim $range01BF (_t0233, _t0234);
  int[] accum0239 = {};
  foreach j0237 in _t0235 {
    int _t0236 = 1;
    int _t0238 = prim +0015 (_t0236, j0237);
    accum0239 = prim @0010<int> (accum0239, _t0238);
  }
  int[] accum023D = {};
  foreach k023A in accum0239 {
    int _t023B = 2;
    int _t023C = prim +0015 (k023A, _t023B);
    accum023D = prim @0010<int> (accum023D, _t023C);
  }
  a1023E = accum023D;
  int _t023F = 0;
  int _t0240 = func ff0230 (_t023F);
  int _t0241 = 1;
  int _t0242 = func ff0230 (_t0241);
  int _t0244 = 0;
  int _t0245 = func ff0230 (_t0244);
  int _t0246 = 1;
  int _t0247 = func ff0230 (_t0246);
  int _t0249 = 0;
  int _t024A = func ff0230 (_t0249);
  int _t024B = 1;
  int _t024C = func ff0230 (_t024B);
  int _t024E = 0;
  int _t024F = 10;
  int[] _t0250 = prim $range01BF (_t024E, _t024F);
  real[] accum0255 = {};
  foreach j0252 in _t0250 {
    real _t0251 = 0.1e1;
    real _t0253 = (real)j0252;
    real _t0254 = prim +0017<$[]> (_t0251, _t0253);
    accum0255 = prim @0010<real> (accum0255, _t0254);
  }
  real[] accum0259 = {};
  foreach k0256 in accum0255 {
    real _t0257 = 0.2e1;
    real _t0258 = prim +0017<$[]> (k0256, _t0257);
    accum0259 = prim @0010<real> (accum0259, _t0258);
  }
  a2025A = accum0259;
}
strand gg (int i0278, int j0279) {
  output real result027A;
  {
    real _t027B = 0.1e1;
    real _t027C = (real)i0278;
    result027A = prim *0034 (_t027B, _t027C);
  }
  update
  {
    int _t027E = 10;
    int _t027F = prim *0033 (i0278, _t027E);
    result027A = func f0271 (result027A, _t027F);
    int _t0280 = 0;
    int _t0281 = prim $sub01BC<int; %2> (ll022C, _t0280);
    string _t0282 = " ! ";
    int _t0283 = 1;
    int _t0284 = prim $sub01BC<int; %2> (ll022C, _t0283);
    string _t0285 = "bah\n";
    print (_t0281, _t0282, _t0284, _t0285);
    string _t0286 = "\n";
    string _t0287 = "numCell:";
    int _t0288 = 2;
    string _t0289 = "\n";
    string _t028A = "\n";
    real _t028B = 0.2e1;
    real _t028C = func s0276 (_t028B);
    string _t028D = "\n";
    string _t028E = "\n";
    print (result027A, _t0286, _t0287, _t0288, _t0289, a1023E, a2025A, _t028A, _t028C, _t028D, j0279, _t028E);
    stabilize;
  }
}
collection {
  foreach j0292 in a1023E {
    int _t028F = 5;
    int _t0290 = 11;
    int[] _t0291 = prim $range01BF (_t028F, _t0290);
    foreach k0293 in _t0291 {
      new gg (j0292, k0293);
    }
  }
}
/* Program end */
/* Simplified Program (after after map-reduce-fusion) start */
properties: GlobalInit,HasGlobals,HasConsts
const int[2] ll022C;
constants {
  int _t022A = 2;
  int _t022B = 2;
  ll022C = {_t022A, _t022B};
}
global int[] a1023E;
global real[] a2025A;
function int#0 unpack022D (int arg0022E)
{
  int _t022F = (int)arg0022E;
  return _t022F;
}
function int#6 ff0230 (int arg00231)
{
  int _t0232 = (int)arg00231;
  return _t0232;
}
function real#1 f0271 (real g0272, int j0273)
{
  real _t0274 = (real)j0273;
  real _t0275 = prim *0034 (g0272, _t0274);
  return _t0275;
}
function real#1 s0276 (real k0277)
{
  print (a1023E);
  return k0277;
}
globalInit {
  int _t0233 = 0;
  int _t0234 = 10;
  int[] _t0235 = prim $range01BF (_t0233, _t0234);
  int[] accum0239 = {};
  foreach j0237 in _t0235 {
    int _t0236 = 1;
    int _t0238 = prim +0015 (_t0236, j0237);
    accum0239 = prim @0010<int> (accum0239, _t0238);
  }
  int[] accum023D = {};
  foreach k023A in accum0239 {
    int _t023B = 2;
    int _t023C = prim +0015 (k023A, _t023B);
    accum023D = prim @0010<int> (accum023D, _t023C);
  }
  a1023E = accum023D;
  int _t023F = 0;
  int _t0240 = func ff0230 (_t023F);
  int _t0241 = 1;
  int _t0242 = func ff0230 (_t0241);
  int _t0244 = 0;
  int _t0245 = func ff0230 (_t0244);
  int _t0246 = 1;
  int _t0247 = func ff0230 (_t0246);
  int _t0249 = 0;
  int _t024A = func ff0230 (_t0249);
  int _t024B = 1;
  int _t024C = func ff0230 (_t024B);
  int _t024E = 0;
  int _t024F = 10;
  int[] _t0250 = prim $range01BF (_t024E, _t024F);
  real[] accum0255 = {};
  foreach j0252 in _t0250 {
    real _t0251 = 0.1e1;
    real _t0253 = (real)j0252;
    real _t0254 = prim +0017<$[]> (_t0251, _t0253);
    accum0255 = prim @0010<real> (accum0255, _t0254);
  }
  real[] accum0259 = {};
  foreach k0256 in accum0255 {
    real _t0257 = 0.2e1;
    real _t0258 = prim +0017<$[]> (k0256, _t0257);
    accum0259 = prim @0010<real> (accum0259, _t0258);
  }
  a2025A = accum0259;
}
strand gg (int i0278, int j0279) {
  output real result027A;
  {
    real _t027B = 0.1e1;
    real _t027C = (real)i0278;
    result027A = prim *0034 (_t027B, _t027C);
  }
  update
  {
    int _t027E = 10;
    int _t027F = prim *0033 (i0278, _t027E);
    result027A = func f0271 (result027A, _t027F);
    int _t0280 = 0;
    int _t0281 = prim $sub01BC<int; %2> (ll022C, _t0280);
    string _t0282 = " ! ";
    int _t0283 = 1;
    int _t0284 = prim $sub01BC<int; %2> (ll022C, _t0283);
    string _t0285 = "bah\n";
    print (_t0281, _t0282, _t0284, _t0285);
    string _t0286 = "\n";
    string _t0287 = "numCell:";
    int _t0288 = 2;
    string _t0289 = "\n";
    string _t028A = "\n";
    real _t028B = 0.2e1;
    real _t028C = func s0276 (_t028B);
    string _t028D = "\n";
    string _t028E = "\n";
    print (result027A, _t0286, _t0287, _t0288, _t0289, a1023E, a2025A, _t028A, _t028C, _t028D, j0279, _t028E);
    stabilize;
  }
}
collection {
  foreach j0292 in a1023E {
    int _t028F = 5;
    int _t0290 = 11;
    int[] _t0291 = prim $range01BF (_t028F, _t0290);
    foreach k0293 in _t0291 {
      new gg (j0292, k0293);
    }
  }
}
/* Program end */
/* Simplified Program (after after inlining) start */
properties: GlobalInit,HasGlobals,HasConsts
const int[2] ll022C;
constants {
  int _t022A = 2;
  int _t022B = 2;
  ll022C = {_t022A, _t022B};
}
global int[] a1023E;
global real[] a2025A;
globalInit {
  int _t0233 = 0;
  int _t0234 = 10;
  int[] _t0235 = prim $range01BF (_t0233, _t0234);
  int[] accum0239 = {};
  foreach j0237 in _t0235 {
    int _t0236 = 1;
    int _t0238 = prim +0015 (_t0236, j0237);
    accum0239 = prim @0010<int> (accum0239, _t0238);
  }
  int[] accum023D = {};
  foreach k023A in accum0239 {
    int _t023B = 2;
    int _t023C = prim +0015 (k023A, _t023B);
    accum023D = prim @0010<int> (accum023D, _t023C);
  }
  a1023E = accum023D;
  int _t023F = 0;
  int _t0240;
  int _t0299 = (int)_t023F;
  _t0240 = _t0299;
  int _t0241 = 1;
  int _t0242;
  int _t0298 = (int)_t0241;
  _t0242 = _t0298;
  int _t0244 = 0;
  int _t0245;
  int _t0297 = (int)_t0244;
  _t0245 = _t0297;
  int _t0246 = 1;
  int _t0247;
  int _t0296 = (int)_t0246;
  _t0247 = _t0296;
  int _t0249 = 0;
  int _t024A;
  int _t0295 = (int)_t0249;
  _t024A = _t0295;
  int _t024B = 1;
  int _t024C;
  int _t0294 = (int)_t024B;
  _t024C = _t0294;
  int _t024E = 0;
  int _t024F = 10;
  int[] _t0250 = prim $range01BF (_t024E, _t024F);
  real[] accum0255 = {};
  foreach j0252 in _t0250 {
    real _t0251 = 0.1e1;
    real _t0253 = (real)j0252;
    real _t0254 = prim +0017<$[]> (_t0251, _t0253);
    accum0255 = prim @0010<real> (accum0255, _t0254);
  }
  real[] accum0259 = {};
  foreach k0256 in accum0255 {
    real _t0257 = 0.2e1;
    real _t0258 = prim +0017<$[]> (k0256, _t0257);
    accum0259 = prim @0010<real> (accum0259, _t0258);
  }
  a2025A = accum0259;
}
strand gg (int i0278, int j0279) {
  output real result027A;
  {
    real _t027B = 0.1e1;
    real _t027C = (real)i0278;
    result027A = prim *0034 (_t027B, _t027C);
  }
  update
  {
    int _t027E = 10;
    int _t027F = prim *0033 (i0278, _t027E);
    real result029A;
    real _t029B = (real)_t027F;
    real _t029C = prim *0034 (result027A, _t029B);
    result029A = _t029C;
    result027A = result029A;
    int _t0280 = 0;
    int _t0281 = prim $sub01BC<int; %2> (ll022C, _t0280);
    string _t0282 = " ! ";
    int _t0283 = 1;
    int _t0284 = prim $sub01BC<int; %2> (ll022C, _t0283);
    string _t0285 = "bah\n";
    print (_t0281, _t0282, _t0284, _t0285);
    string _t0286 = "\n";
    string _t0287 = "numCell:";
    int _t0288 = 2;
    string _t0289 = "\n";
    string _t028A = "\n";
    real _t028B = 0.2e1;
    real _t028C;
    print (a1023E);
    _t028C = _t028B;
    string _t028D = "\n";
    string _t028E = "\n";
    print (result027A, _t0286, _t0287, _t0288, _t0289, a1023E, a2025A, _t028A, _t028C, _t028D, j0279, _t028E);
    stabilize;
  }
}
collection {
  foreach j0292 in a1023E {
    int _t028F = 5;
    int _t0290 = 11;
    int[] _t0291 = prim $range01BF (_t028F, _t0290);
    foreach k0293 in _t0291 {
      new gg (j0292, k0293);
    }
  }
}
/* Program end */
/* Simplified Program (after after contraction (2)) start */
properties: GlobalInit,HasGlobals,HasConsts
const int[2] ll022C;
constants {
  int _t022A = 2;
  int _t022B = 2;
  ll022C = {_t022A, _t022B};
}
global int[] a1023E;
global real[] a2025A;
globalInit {
  int _t0233 = 0;
  int _t0234 = 10;
  int[] _t0235 = prim $range01BF (_t0233, _t0234);
  int[] accum0239 = {};
  foreach j0237 in _t0235 {
    int _t0236 = 1;
    int _t0238 = prim +0015 (_t0236, j0237);
    accum0239 = prim @0010<int> (accum0239, _t0238);
  }
  int[] accum023D = {};
  foreach k023A in accum0239 {
    int _t023B = 2;
    int _t023C = prim +0015 (k023A, _t023B);
    accum023D = prim @0010<int> (accum023D, _t023C);
  }
  a1023E = accum023D;
  int _t023F = 0;
  int _t0241 = 1;
  int _t0244 = 0;
  int _t0246 = 1;
  int _t0249 = 0;
  int _t024B = 1;
  int _t024E = 0;
  int _t024F = 10;
  int[] _t0250 = prim $range01BF (_t024E, _t024F);
  real[] accum0255 = {};
  foreach j0252 in _t0250 {
    real _t0251 = 0.1e1;
    real _t0253 = (real)j0252;
    real _t0254 = prim +0017<$[]> (_t0251, _t0253);
    accum0255 = prim @0010<real> (accum0255, _t0254);
  }
  real[] accum0259 = {};
  foreach k0256 in accum0255 {
    real _t0257 = 0.2e1;
    real _t0258 = prim +0017<$[]> (k0256, _t0257);
    accum0259 = prim @0010<real> (accum0259, _t0258);
  }
  a2025A = accum0259;
}
strand gg (int i0278, int j0279) {
  output real result027A;
  {
    real _t027B = 0.1e1;
    real _t027C = (real)i0278;
    result027A = prim *0034 (_t027B, _t027C);
  }
  update
  {
    int _t027E = 10;
    int _t027F = prim *0033 (i0278, _t027E);
    real result029A;
    real _t029B = (real)_t027F;
    real _t029C = prim *0034 (result027A, _t029B);
    result029A = _t029C;
    result027A = result029A;
    int _t0280 = 0;
    int _t0281 = prim $sub01BC<int; %2> (ll022C, _t0280);
    string _t0282 = " ! ";
    int _t0283 = 1;
    int _t0284 = prim $sub01BC<int; %2> (ll022C, _t0283);
    string _t0285 = "bah\n";
    print (_t0281, _t0282, _t0284, _t0285);
    string _t0286 = "\n";
    string _t0287 = "numCell:";
    int _t0288 = 2;
    string _t0289 = "\n";
    string _t028A = "\n";
    real _t028B = 0.2e1;
    real _t028C;
    print (a1023E);
    _t028C = _t028B;
    string _t028D = "\n";
    string _t028E = "\n";
    print (result027A, _t0286, _t0287, _t0288, _t0289, a1023E, a2025A, _t028A, _t028C, _t028D, j0279, _t028E);
    stabilize;
  }
}
collection {
  foreach j0292 in a1023E {
    int _t028F = 5;
    int _t0290 = 11;
    int[] _t0291 = prim $range01BF (_t028F, _t0290);
    foreach k0293 in _t0291 {
      new gg (j0292, k0293);
    }
  }
}
/* Program end */
/* Simplified Program (after after simplify fields) start */
properties: GlobalInit,HasGlobals,HasConsts
const int[2] ll022C;
constants {
  int _t022A = 2;
  int _t022B = 2;
  ll022C = {_t022A, _t022B};
}
global int[] a1023E;
global real[] a2025A;
globalInit {
  int _t0233 = 0;
  int _t0234 = 10;
  int[] _t0235 = prim $range01BF (_t0233, _t0234);
  int[] accum0239 = {};
  foreach j0237 in _t0235 {
    int _t0236 = 1;
    int _t0238 = prim +0015 (_t0236, j0237);
    accum0239 = prim @0010<int> (accum0239, _t0238);
  }
  int[] accum023D = {};
  foreach k023A in accum0239 {
    int _t023B = 2;
    int _t023C = prim +0015 (k023A, _t023B);
    accum023D = prim @0010<int> (accum023D, _t023C);
  }
  a1023E = accum023D;
  int _t023F = 0;
  int _t0241 = 1;
  int _t0244 = 0;
  int _t0246 = 1;
  int _t0249 = 0;
  int _t024B = 1;
  int _t024E = 0;
  int _t024F = 10;
  int[] _t0250 = prim $range01BF (_t024E, _t024F);
  real[] accum0255 = {};
  foreach j0252 in _t0250 {
    real _t0251 = 0.1e1;
    real _t0253 = (real)j0252;
    real _t0254 = prim +0017<$[]> (_t0251, _t0253);
    accum0255 = prim @0010<real> (accum0255, _t0254);
  }
  real[] accum0259 = {};
  foreach k0256 in accum0255 {
    real _t0257 = 0.2e1;
    real _t0258 = prim +0017<$[]> (k0256, _t0257);
    accum0259 = prim @0010<real> (accum0259, _t0258);
  }
  a2025A = accum0259;
}
strand gg (int i0278, int j0279) {
  output real result027A;
  {
    real _t027B = 0.1e1;
    real _t027C = (real)i0278;
    result027A = prim *0034 (_t027B, _t027C);
  }
  update
  {
    int _t027E = 10;
    int _t027F = prim *0033 (i0278, _t027E);
    real result029A;
    real _t029B = (real)_t027F;
    real _t029C = prim *0034 (result027A, _t029B);
    result029A = _t029C;
    result027A = result029A;
    int _t0280 = 0;
    int _t0281 = prim $sub01BC<int; %2> (ll022C, _t0280);
    string _t0282 = " ! ";
    int _t0283 = 1;
    int _t0284 = prim $sub01BC<int; %2> (ll022C, _t0283);
    string _t0285 = "bah\n";
    print (_t0281, _t0282, _t0284, _t0285);
    string _t0286 = "\n";
    string _t0287 = "numCell:";
    int _t0288 = 2;
    string _t0289 = "\n";
    string _t028A = "\n";
    real _t028B = 0.2e1;
    real _t028C;
    print (a1023E);
    _t028C = _t028B;
    string _t028D = "\n";
    string _t028E = "\n";
    print (result027A, _t0286, _t0287, _t0288, _t0289, a1023E, a2025A, _t028A, _t028C, _t028D, j0279, _t028E);
    stabilize;
  }
}
collection {
  foreach j0292 in a1023E {
    int _t028F = 5;
    int _t0290 = 11;
    int[] _t0291 = prim $range01BF (_t028F, _t0290);
    foreach k0293 in _t0291 {
      new gg (j0292, k0293);
    }
  }
}
/* Program end */
/* Simplified Program (after after simplify variables) start */
properties: GlobalInit,HasGlobals,HasConsts
const int[2] ll022C;
constants {
  int _t022A = 2;
  int _t022B = 2;
  ll022C = {_t022A, _t022B};
}
global int[] a1023E;
global real[] a2025A;
globalInit {
  int _t0233 = 0;
  int _t0234 = 10;
  int[] _t0235 = prim $range01BF (_t0233, _t0234);
  int[] accum0239 = {};
  foreach j0237 in _t0235 {
    int _t0236 = 1;
    int _t0238 = prim +0015 (_t0236, j0237);
    accum0239 = prim @0010<int> (accum0239, _t0238);
  }
  int[] accum023D = {};
  foreach k023A in accum0239 {
    int _t023B = 2;
    int _t023C = prim +0015 (k023A, _t023B);
    accum023D = prim @0010<int> (accum023D, _t023C);
  }
  a1023E = accum023D;
  int _t023F = 0;
  int _t0241 = 1;
  int _t0244 = 0;
  int _t0246 = 1;
  int _t0249 = 0;
  int _t024B = 1;
  int _t024E = 0;
  int _t024F = 10;
  int[] _t0250 = prim $range01BF (_t024E, _t024F);
  real[] accum0255 = {};
  foreach j0252 in _t0250 {
    real _t0251 = 0.1e1;
    real _t0253 = (real)j0252;
    real _t0254 = prim +0017<$[]> (_t0251, _t0253);
    accum0255 = prim @0010<real> (accum0255, _t0254);
  }
  real[] accum0259 = {};
  foreach k0256 in accum0255 {
    real _t0257 = 0.2e1;
    real _t0258 = prim +0017<$[]> (k0256, _t0257);
    accum0259 = prim @0010<real> (accum0259, _t0258);
  }
  a2025A = accum0259;
}
strand gg (int i0278, int j0279) {
  output real result027A;
  int i029E;
  int j029D;
  {
    real _t027B = 0.1e1;
    real _t027C = (real)i0278;
    result027A = prim *0034 (_t027B, _t027C);
    i029E = i0278;
    j029D = j0279;
  }
  update
  {
    int _t027E = 10;
    int _t027F = prim *0033 (i029E, _t027E);
    real result029A;
    real _t029B = (real)_t027F;
    real _t029C = prim *0034 (result027A, _t029B);
    result029A = _t029C;
    result027A = result029A;
    int _t0280 = 0;
    int _t0281 = prim $sub01BC<int; %2> (ll022C, _t0280);
    string _t0282 = " ! ";
    int _t0283 = 1;
    int _t0284 = prim $sub01BC<int; %2> (ll022C, _t0283);
    string _t0285 = "bah\n";
    print (_t0281, _t0282, _t0284, _t0285);
    string _t0286 = "\n";
    string _t0287 = "numCell:";
    int _t0288 = 2;
    string _t0289 = "\n";
    string _t028A = "\n";
    real _t028B = 0.2e1;
    real _t028C;
    print (a1023E);
    _t028C = _t028B;
    string _t028D = "\n";
    string _t028E = "\n";
    print (result027A, _t0286, _t0287, _t0288, _t0289, a1023E, a2025A, _t028A, _t028C, _t028D, j029D, _t028E);
    stabilize;
  }
}
collection {
  foreach j0292 in a1023E {
    int _t028F = 5;
    int _t0290 = 11;
    int[] _t0291 = prim $range01BF (_t028F, _t0290);
    foreach k0293 in _t0291 {
      new gg (j0292, k0293);
    }
  }
}
/* Program end */
/* Simplified Program (after after simplify fem vars) start */
properties: GlobalInit,HasGlobals,HasConsts
const int[2] ll022C;
constants {
  int _t022A = 2;
  int _t022B = 2;
  ll022C = {_t022A, _t022B};
}
global int[] a1023E;
global real[] a2025A;
globalInit {
  int _t0233 = 0;
  int _t0234 = 10;
  int[] _t0235 = prim $range01BF (_t0233, _t0234);
  int[] accum0239 = {};
  foreach j0237 in _t0235 {
    int _t0236 = 1;
    int _t0238 = prim +0015 (_t0236, j0237);
    accum0239 = prim @0010<int> (accum0239, _t0238);
  }
  int[] accum023D = {};
  foreach k023A in accum0239 {
    int _t023B = 2;
    int _t023C = prim +0015 (k023A, _t023B);
    accum023D = prim @0010<int> (accum023D, _t023C);
  }
  a1023E = accum023D;
  int _t023F = 0;
  int _t0241 = 1;
  int _t0244 = 0;
  int _t0246 = 1;
  int _t0249 = 0;
  int _t024B = 1;
  int _t024E = 0;
  int _t024F = 10;
  int[] _t0250 = prim $range01BF (_t024E, _t024F);
  real[] accum0255 = {};
  foreach j0252 in _t0250 {
    real _t0251 = 0.1e1;
    real _t0253 = (real)j0252;
    real _t0254 = prim +0017<$[]> (_t0251, _t0253);
    accum0255 = prim @0010<real> (accum0255, _t0254);
  }
  real[] accum0259 = {};
  foreach k0256 in accum0255 {
    real _t0257 = 0.2e1;
    real _t0258 = prim +0017<$[]> (k0256, _t0257);
    accum0259 = prim @0010<real> (accum0259, _t0258);
  }
  a2025A = accum0259;
}
strand gg (int i0278, int j0279) {
  output real result027A;
  int i029E;
  int j029D;
  {
    real _t027B = 0.1e1;
    real _t027C = (real)i0278;
    result027A = prim *0034 (_t027B, _t027C);
    i029E = i0278;
    j029D = j0279;
  }
  update
  {
    int _t027E = 10;
    int _t027F = prim *0033 (i029E, _t027E);
    real result029A;
    real _t029B = (real)_t027F;
    real _t029C = prim *0034 (result027A, _t029B);
    result029A = _t029C;
    result027A = result029A;
    int _t0280 = 0;
    int _t0281 = prim $sub01BC<int; %2> (ll022C, _t0280);
    string _t0282 = " ! ";
    int _t0283 = 1;
    int _t0284 = prim $sub01BC<int; %2> (ll022C, _t0283);
    string _t0285 = "bah\n";
    print (_t0281, _t0282, _t0284, _t0285);
    string _t0286 = "\n";
    string _t0287 = "numCell:";
    int _t0288 = 2;
    string _t0289 = "\n";
    string _t028A = "\n";
    real _t028B = 0.2e1;
    real _t028C;
    print (a1023E);
    _t028C = _t028B;
    string _t028D = "\n";
    string _t028E = "\n";
    print (result027A, _t0286, _t0287, _t0288, _t0289, a1023E, a2025A, _t028A, _t028C, _t028D, j029D, _t028E);
    stabilize;
  }
}
collection {
  foreach j0292 in a1023E {
    int _t028F = 5;
    int _t0290 = 11;
    int[] _t0291 = prim $range01BF (_t028F, _t0290);
    foreach k0293 in _t0291 {
      new gg (j0292, k0293);
    }
  }
}
/* Program end */
##### high-ir: after simple-to-high translation ####
## properties
  GlobalInit HasGlobals HasConsts
## globals
  const int[2] ll029F
  global int[] a102A9
  global real[] a202AA
## functions
## input initialization
  ENTRY02A7:  preds = []
    int _t02A0#1 = 2;
    int _t02A2#1 = 2;
    int[2] ll02A4#1 = <int[2]>{_t02A0,_t02A2};
    globals.ll029F = ll02A4;
    return
## global-variable initialization
  ENTRY02FB:  preds = []
    int _t02AB#1 = 0;
    int _t02AD#1 = 10;
    int[] _t02AF#1 = Range(_t02AB,_t02AD);
    int[] accum02B1#1 = <int[]>{};
  FOREACH02B5:  preds = [ASSIGN02B2,NEXT02BC]
    foreach (j02B3 in _t02AF) on exit goto ASSIGN02BE
      int[] accum02B4#2 = phi(accum02B1,accum02BA)
    int _t02B6#1 = 1;
    int _t02B8#1 = IAdd(_t02B6,j02B3);
    int[] accum02BA#1 = Append<int>(accum02B4,_t02B8);
    goto FOREACH02B5
  ASSIGN02BE:  preds = [FOREACH02B5]
    int[] accum02BD#1 = <int[]>{};
  FOREACH02C1:  preds = [ASSIGN02BE,NEXT02C8]
    foreach (k02BF in accum02B4) on exit goto ASSIGN02CA
      int[] accum02C0#2 = phi(accum02BD,accum02C6)
    int _t02C2#1 = 2;
    int _t02C4#1 = IAdd(k02BF,_t02C2);
    int[] accum02C6#1 = Append<int>(accum02C0,_t02C4);
    goto FOREACH02C1
  ASSIGN02CA:  preds = [FOREACH02C1]
    int[] a102C9#1 = accum02C0;
    globals.a102A9 = a102C9;
    int _t02CC#0 = 0;
    int _t02CE#0 = 1;
    int _t02D0#0 = 0;
    int _t02D2#0 = 1;
    int _t02D4#0 = 0;
    int _t02D6#0 = 1;
    int _t02D8#1 = 0;
    int _t02DA#1 = 10;
    int[] _t02DC#1 = Range(_t02D8,_t02DA);
    real[] accum02DE#1 = <real[]>{};
  FOREACH02E2:  preds = [ASSIGN02DF,NEXT02EB]
    foreach (j02E0 in _t02DC) on exit goto ASSIGN02ED
      real[] accum02E1#2 = phi(accum02DE,accum02E9)
    real _t02E3#1 = 0.1e1;
    real _t02E5#1 = IntToReal(j02E0);
    real _t02E7#1 = λ(T0[],T1[])<(T0 + T1)> (_t02E3,_t02E5);
    real[] accum02E9#1 = Append<real>(accum02E1,_t02E7);
    goto FOREACH02E2
  ASSIGN02ED:  preds = [FOREACH02E2]
    real[] accum02EC#1 = <real[]>{};
  FOREACH02F0:  preds = [ASSIGN02ED,NEXT02F7]
    foreach (k02EE in accum02E1) on exit goto ASSIGN02F9
      real[] accum02EF#2 = phi(accum02EC,accum02F5)
    real _t02F1#1 = 0.2e1;
    real _t02F3#1 = λ(T0[],T1[])<(T0 + T1)> (k02EE,_t02F1);
    real[] accum02F5#1 = Append<real>(accum02EF,_t02F3);
    goto FOREACH02F0
  ASSIGN02F9:  preds = [FOREACH02F0]
    real[] a202F8#1 = accum02EF;
    globals.a202AA = a202F8;
    return
## strand
  strand gg (int i030E#2, int j030F#1)
    state:
      output real result;
      int i;
      int j;
    state init
      ENTRY0320:  preds = []
        real _t0316#1 = 0.1e1;
        real _t0318#1 = IntToReal(i030E);
        real result031A#1 = λ(T0[],T1[])<(T0 * T1)> (_t0316,_t0318);
        int i031C#1 = i030E;
        int j031E#1 = j030F;
        self.result = result031A;
        self.i = i031C;
        self.j = j031E;
        return
    end state init
    method update
        ENTRY0362:  preds = []
          int[2] ll0327#2 = globals.ll029F;
          int[] a10326#2 = globals.a102A9;
          real[] a20325#1 = globals.a202AA;
          real result032B#1 = self.result;
          int i032C#1 = self.i;
          int j032D#1 = self.j;
          int _t0331#1 = 10;
          int _t0333#1 = IMul(i032C,_t0331);
          real _t0336#1 = IntToReal(_t0333);
          real _t0338#1 = λ(T0[],T1[])<(T0 * T1)> (result032B,_t0336);
          real result033A#1 = _t0338;
          real result033C#2 = result033A;
          int _t033E#1 = 0;
          int _t0340#1 = Subscript<int[2]>(ll0327,_t033E);
          string _t0342#1 = " ! ";
          int _t0344#1 = 1;
          int _t0346#1 = Subscript<int[2]>(ll0327,_t0344);
          string _t0348#1 = "bah\n";
          Print<[int,string,int,string]>(_t0340,_t0342,_t0346,_t0348);
          string _t034B#1 = "\n";
          string _t034D#1 = "numCell:";
          int _t034F#1 = 2;
          string _t0351#1 = "\n";
          string _t0353#1 = "\n";
          real _t0355#1 = 0.2e1;
          Print<[int[]]>(a10326);
          real _t0359#1 = _t0355;
          string _t035B#1 = "\n";
          string _t035D#1 = "\n";
          Print<[real,string,string,int,string,int[],real[],string,real,string,int,string]>(result033C,_t034B,_t034D,_t034F,_t0351,a10326,a20325,_t0353,_t0359,_t035B,j032D,_t035D);
          self.result = result033C;
          stabilize
    end update
  end gg
## initial strand creation
  COLLECTION
    ENTRY030C:  preds = []
      int[] a102FD#1 = globals.a102A9;
    FOREACH0300:  preds = [ASSIGN02FE,NEXT030B]
      foreach (j02FF in a102FD) on exit goto RETURN030D
      int _t0301#1 = 5;
      int _t0303#1 = 11;
      int[] _t0305#1 = Range(_t0301,_t0303);
    FOREACH0308:  preds = [ASSIGN0306,NEXT030A]
      foreach (k0307 in _t0305) on exit goto NEXT030B
      new gg(j02FF,k0307);
      goto FOREACH0308
    NEXT030B:  preds = [FOREACH0308]
      goto FOREACH0300
    RETURN030D:  preds = [FOREACH0300]
      return
#### end program ####
##### high-ir: after value numbering ####
## properties
  GlobalInit HasGlobals HasConsts
## globals
  const int[2] ll029F
  global int[] a102A9
  global real[] a202AA
## functions
## input initialization
  ENTRY02A7:  preds = []
    int _t02A0#2 = 2;
    int[2] ll02A4#1 = <int[2]>{_t02A0,_t02A0};
    globals.ll029F = ll02A4;
    return
## global-variable initialization
  ENTRY02FB:  preds = []
    int _t02AB#1 = 0;
    int _t02AD#1 = 10;
    int[] _t02AF#2 = Range(_t02AB,_t02AD);
    int[] accum02B1#1 = <int[]>{};
  FOREACH02B5:  preds = [ASSIGN02B2,NEXT02BC]
    foreach (j02B3 in _t02AF) on exit goto ASSIGN02BE
      int[] accum02B4#2 = phi(accum02B1,accum02BA)
    int _t02B6#1 = 1;
    int _t02B8#1 = IAdd(_t02B6,j02B3);
    int[] accum02BA#1 = Append<int>(accum02B4,_t02B8);
    goto FOREACH02B5
  ASSIGN02BE:  preds = [FOREACH02B5]
    int[] accum02BD#1 = <int[]>{};
  FOREACH02C1:  preds = [ASSIGN02BE,NEXT02C8]
    foreach (k02BF in accum02B4) on exit goto GASSIGN0365
      int[] accum02C0#2 = phi(accum02BD,accum02C6)
    int _t02C2#1 = 2;
    int _t02C4#1 = IAdd(k02BF,_t02C2);
    int[] accum02C6#1 = Append<int>(accum02C0,_t02C4);
    goto FOREACH02C1
  GASSIGN0365:  preds = [FOREACH02C1]
    globals.a102A9 = accum02C0;
    int _t02CE#0 = 1;
    real[] accum02DE#1 = <real[]>{};
  FOREACH02E2:  preds = [ASSIGN02DF,NEXT02EB]
    foreach (j02E0 in _t02AF) on exit goto ASSIGN02ED
      real[] accum02E1#2 = phi(accum02DE,accum02E9)
    real _t02E3#1 = 0.1e1;
    real _t02E5#1 = IntToReal(j02E0);
    real _t02E7#1 = λ(T0[],T1[])<(T0 + T1)> (_t02E3,_t02E5);
    real[] accum02E9#1 = Append<real>(accum02E1,_t02E7);
    goto FOREACH02E2
  ASSIGN02ED:  preds = [FOREACH02E2]
    real[] accum02EC#1 = <real[]>{};
  FOREACH02F0:  preds = [ASSIGN02ED,NEXT02F7]
    foreach (k02EE in accum02E1) on exit goto GASSIGN0366
      real[] accum02EF#2 = phi(accum02EC,accum02F5)
    real _t02F1#1 = 0.2e1;
    real _t02F3#1 = λ(T0[],T1[])<(T0 + T1)> (k02EE,_t02F1);
    real[] accum02F5#1 = Append<real>(accum02EF,_t02F3);
    goto FOREACH02F0
  GASSIGN0366:  preds = [FOREACH02F0]
    globals.a202AA = accum02EF;
    return
## strand
  strand gg (int i030E#2, int j030F#1)
    state:
      output real result;
      int i;
      int j;
    state init
      ENTRY0320:  preds = []
        real _t0316#1 = 0.1e1;
        real _t0318#1 = IntToReal(i030E);
        real result031A#1 = λ(T0[],T1[])<(T0 * T1)> (_t0316,_t0318);
        self.result = result031A;
        self.i = i030E;
        self.j = j030F;
        return
    end state init
    method update
        ENTRY0362:  preds = []
          int[2] ll0327#2 = globals.ll029F;
          int[] a10326#2 = globals.a102A9;
          real[] a20325#1 = globals.a202AA;
          real result032B#1 = self.result;
          int i032C#1 = self.i;
          int j032D#1 = self.j;
          int _t0331#1 = 10;
          int _t0333#1 = IMul(i032C,_t0331);
          real _t0336#1 = IntToReal(_t0333);
          real _t0338#2 = λ(T0[],T1[])<(T0 * T1)> (result032B,_t0336);
          int _t033E#1 = 0;
          int _t0340#1 = Subscript<int[2]>(ll0327,_t033E);
          string _t0342#1 = " ! ";
          int _t0344#1 = 1;
          int _t0346#1 = Subscript<int[2]>(ll0327,_t0344);
          string _t0348#1 = "bah\n";
          Print<[int,string,int,string]>(_t0340,_t0342,_t0346,_t0348);
          string _t034B#5 = "\n";
          string _t034D#1 = "numCell:";
          int _t034F#1 = 2;
          real _t0355#1 = 0.2e1;
          Print<[int[]]>(a10326);
          Print<[real,string,string,int,string,int[],real[],string,real,string,int,string]>(_t0338,_t034B,_t034D,_t034F,_t034B,a10326,a20325,_t034B,_t0355,_t034B,j032D,_t034B);
          self.result = _t0338;
          stabilize
    end update
  end gg
## initial strand creation
  COLLECTION
    ENTRY030C:  preds = []
      int[] a102FD#1 = globals.a102A9;
    FOREACH0300:  preds = [ASSIGN02FE,NEXT030B]
      foreach (j02FF in a102FD) on exit goto RETURN030D
      int _t0301#1 = 5;
      int _t0303#1 = 11;
      int[] _t0305#1 = Range(_t0301,_t0303);
    FOREACH0308:  preds = [ASSIGN0306,NEXT030A]
      foreach (k0307 in _t0305) on exit goto NEXT030B
      new gg(j02FF,k0307);
      goto FOREACH0308
    NEXT030B:  preds = [FOREACH0308]
      goto FOREACH0300
    RETURN030D:  preds = [FOREACH0300]
      return
#### end program ####
##### high-ir: after normalization rewriting ####
## properties
  GlobalInit HasGlobals HasConsts
## globals
  const int[2] ll029F
  global int[] a102A9
  global real[] a202AA
## functions
## input initialization
  ENTRY02A7:  preds = []
    int _t02A0#2 = 2;
    int[2] ll02A4#1 = <int[2]>{_t02A0,_t02A0};
    globals.ll029F = ll02A4;
    return
## global-variable initialization
  ENTRY02FB:  preds = []
    int _t02AB#1 = 0;
    int _t02AD#1 = 10;
    int[] _t02AF#2 = Range(_t02AB,_t02AD);
    int[] accum02B1#1 = <int[]>{};
  FOREACH02B5:  preds = [ASSIGN02B2,NEXT02BC]
    foreach (j02B3 in _t02AF) on exit goto ASSIGN02BE
      int[] accum02B4#2 = phi(accum02B1,accum02BA)
    int _t02B6#1 = 1;
    int _t02B8#1 = IAdd(_t02B6,j02B3);
    int[] accum02BA#1 = Append<int>(accum02B4,_t02B8);
    goto FOREACH02B5
  ASSIGN02BE:  preds = [FOREACH02B5]
    int[] accum02BD#1 = <int[]>{};
  FOREACH02C1:  preds = [ASSIGN02BE,NEXT02C8]
    foreach (k02BF in accum02B4) on exit goto GASSIGN0365
      int[] accum02C0#2 = phi(accum02BD,accum02C6)
    int _t02C2#1 = 2;
    int _t02C4#1 = IAdd(k02BF,_t02C2);
    int[] accum02C6#1 = Append<int>(accum02C0,_t02C4);
    goto FOREACH02C1
  GASSIGN0365:  preds = [FOREACH02C1]
    globals.a102A9 = accum02C0;
    real[] accum02DE#1 = <real[]>{};
  FOREACH02E2:  preds = [ASSIGN02DF,NEXT02EB]
    foreach (j02E0 in _t02AF) on exit goto ASSIGN02ED
      real[] accum02E1#2 = phi(accum02DE,accum02E9)
    real _t02E3#1 = 0.1e1;
    real _t02E5#1 = IntToReal(j02E0);
    real _t02E7#1 = λ(T0[],T1[])<(T0 + T1)> (_t02E3,_t02E5);
    real[] accum02E9#1 = Append<real>(accum02E1,_t02E7);
    goto FOREACH02E2
  ASSIGN02ED:  preds = [FOREACH02E2]
    real[] accum02EC#1 = <real[]>{};
  FOREACH02F0:  preds = [ASSIGN02ED,NEXT02F7]
    foreach (k02EE in accum02E1) on exit goto GASSIGN0366
      real[] accum02EF#2 = phi(accum02EC,accum02F5)
    real _t02F1#1 = 0.2e1;
    real _t02F3#1 = λ(T0[],T1[])<(T0 + T1)> (k02EE,_t02F1);
    real[] accum02F5#1 = Append<real>(accum02EF,_t02F3);
    goto FOREACH02F0
  GASSIGN0366:  preds = [FOREACH02F0]
    globals.a202AA = accum02EF;
    return
## strand
  strand gg (int i030E#2, int j030F#1)
    state:
      output real result;
      int i;
      int j;
    state init
      ENTRY0320:  preds = []
        real _t0316#1 = 0.1e1;
        real _t0318#1 = IntToReal(i030E);
        real result031A#1 = λ(T0[],T1[])<(T0 * T1)> (_t0316,_t0318);
        self.result = result031A;
        self.i = i030E;
        self.j = j030F;
        return
    end state init
    method update
        ENTRY0362:  preds = []
          int[2] ll0327#2 = globals.ll029F;
          int[] a10326#2 = globals.a102A9;
          real[] a20325#1 = globals.a202AA;
          real result032B#1 = self.result;
          int i032C#1 = self.i;
          int j032D#1 = self.j;
          int _t0331#1 = 10;
          int _t0333#1 = IMul(i032C,_t0331);
          real _t0336#1 = IntToReal(_t0333);
          real _t0338#2 = λ(T0[],T1[])<(T0 * T1)> (result032B,_t0336);
          int _t033E#1 = 0;
          int _t0340#1 = Subscript<int[2]>(ll0327,_t033E);
          string _t0342#1 = " ! ";
          int _t0344#1 = 1;
          int _t0346#1 = Subscript<int[2]>(ll0327,_t0344);
          string _t0348#1 = "bah\n";
          Print<[int,string,int,string]>(_t0340,_t0342,_t0346,_t0348);
          string _t034B#5 = "\n";
          string _t034D#1 = "numCell:";
          int _t034F#1 = 2;
          real _t0355#1 = 0.2e1;
          Print<[int[]]>(a10326);
          Print<[real,string,string,int,string,int[],real[],string,real,string,int,string]>(_t0338,_t034B,_t034D,_t034F,_t034B,a10326,a20325,_t034B,_t0355,_t034B,j032D,_t034B);
          self.result = _t0338;
          stabilize
    end update
  end gg
## initial strand creation
  COLLECTION
    ENTRY030C:  preds = []
      int[] a102FD#1 = globals.a102A9;
    FOREACH0300:  preds = [ASSIGN02FE,NEXT030B]
      foreach (j02FF in a102FD) on exit goto RETURN030D
      int _t0301#1 = 5;
      int _t0303#1 = 11;
      int[] _t0305#1 = Range(_t0301,_t0303);
    FOREACH0308:  preds = [ASSIGN0306,NEXT030A]
      foreach (k0307 in _t0305) on exit goto NEXT030B
      new gg(j02FF,k0307);
      goto FOREACH0308
    NEXT030B:  preds = [FOREACH0308]
      goto FOREACH0300
    RETURN030D:  preds = [FOREACH0300]
      return
#### end program ####
##### high-ir: after normalization promotion ####
## properties
  GlobalInit HasGlobals HasConsts
## globals
  const int[2] ll029F
  global int[] a102A9
  global real[] a202AA
## functions
## input initialization
  ENTRY02A7:  preds = []
    int _t02A0#2 = 2;
    int[2] ll02A4#1 = <int[2]>{_t02A0,_t02A0};
    globals.ll029F = ll02A4;
    return
## global-variable initialization
  ENTRY02FB:  preds = []
    int _t02AB#1 = 0;
    int _t02AD#1 = 10;
    int[] _t02AF#2 = Range(_t02AB,_t02AD);
    int[] accum02B1#1 = <int[]>{};
  FOREACH02B5:  preds = [ASSIGN02B2,NEXT02BC]
    foreach (j02B3 in _t02AF) on exit goto ASSIGN02BE
      int[] accum02B4#2 = phi(accum02B1,accum02BA)
    int _t02B6#1 = 1;
    int _t02B8#1 = IAdd(_t02B6,j02B3);
    int[] accum02BA#1 = Append<int>(accum02B4,_t02B8);
    goto FOREACH02B5
  ASSIGN02BE:  preds = [FOREACH02B5]
    int[] accum02BD#1 = <int[]>{};
  FOREACH02C1:  preds = [ASSIGN02BE,NEXT02C8]
    foreach (k02BF in accum02B4) on exit goto GASSIGN0365
      int[] accum02C0#2 = phi(accum02BD,accum02C6)
    int _t02C2#1 = 2;
    int _t02C4#1 = IAdd(k02BF,_t02C2);
    int[] accum02C6#1 = Append<int>(accum02C0,_t02C4);
    goto FOREACH02C1
  GASSIGN0365:  preds = [FOREACH02C1]
    globals.a102A9 = accum02C0;
    real[] accum02DE#1 = <real[]>{};
  FOREACH02E2:  preds = [ASSIGN02DF,NEXT02EB]
    foreach (j02E0 in _t02AF) on exit goto ASSIGN02ED
      real[] accum02E1#2 = phi(accum02DE,accum02E9)
    real _t02E3#1 = 0.1e1;
    real _t02E5#1 = IntToReal(j02E0);
    real _t02E7#1 = λ(T0[],T1[])<(T0 + T1)> (_t02E3,_t02E5);
    real[] accum02E9#1 = Append<real>(accum02E1,_t02E7);
    goto FOREACH02E2
  ASSIGN02ED:  preds = [FOREACH02E2]
    real[] accum02EC#1 = <real[]>{};
  FOREACH02F0:  preds = [ASSIGN02ED,NEXT02F7]
    foreach (k02EE in accum02E1) on exit goto GASSIGN0366
      real[] accum02EF#2 = phi(accum02EC,accum02F5)
    real _t02F1#1 = 0.2e1;
    real _t02F3#1 = λ(T0[],T1[])<(T0 + T1)> (k02EE,_t02F1);
    real[] accum02F5#1 = Append<real>(accum02EF,_t02F3);
    goto FOREACH02F0
  GASSIGN0366:  preds = [FOREACH02F0]
    globals.a202AA = accum02EF;
    return
## strand
  strand gg (int i030E#2, int j030F#1)
    state:
      output real result;
      int i;
      int j;
    state init
      ENTRY0320:  preds = []
        real _t0316#1 = 0.1e1;
        real _t0318#1 = IntToReal(i030E);
        real result031A#1 = λ(T0[],T1[])<(T0 * T1)> (_t0316,_t0318);
        self.result = result031A;
        self.i = i030E;
        self.j = j030F;
        return
    end state init
    method update
        ENTRY0362:  preds = []
          int[2] ll0327#2 = globals.ll029F;
          int[] a10326#2 = globals.a102A9;
          real[] a20325#1 = globals.a202AA;
          real result032B#1 = self.result;
          int i032C#1 = self.i;
          int j032D#1 = self.j;
          int _t0331#1 = 10;
          int _t0333#1 = IMul(i032C,_t0331);
          real _t0336#1 = IntToReal(_t0333);
          real _t0338#2 = λ(T0[],T1[])<(T0 * T1)> (result032B,_t0336);
          int _t033E#1 = 0;
          int _t0340#1 = Subscript<int[2]>(ll0327,_t033E);
          string _t0342#1 = " ! ";
          int _t0344#1 = 1;
          int _t0346#1 = Subscript<int[2]>(ll0327,_t0344);
          string _t0348#1 = "bah\n";
          Print<[int,string,int,string]>(_t0340,_t0342,_t0346,_t0348);
          string _t034B#5 = "\n";
          string _t034D#1 = "numCell:";
          int _t034F#1 = 2;
          real _t0355#1 = 0.2e1;
          Print<[int[]]>(a10326);
          Print<[real,string,string,int,string,int[],real[],string,real,string,int,string]>(_t0338,_t034B,_t034D,_t034F,_t034B,a10326,a20325,_t034B,_t0355,_t034B,j032D,_t034B);
          self.result = _t0338;
          stabilize
    end update
  end gg
## initial strand creation
  COLLECTION
    ENTRY030C:  preds = []
      int[] a102FD#1 = globals.a102A9;
    FOREACH0300:  preds = [ASSIGN02FE,NEXT030B]
      foreach (j02FF in a102FD) on exit goto RETURN030D
      int _t0301#1 = 5;
      int _t0303#1 = 11;
      int[] _t0305#1 = Range(_t0301,_t0303);
    FOREACH0308:  preds = [ASSIGN0306,NEXT030A]
      foreach (k0307 in _t0305) on exit goto NEXT030B
      new gg(j02FF,k0307);
      goto FOREACH0308
    NEXT030B:  preds = [FOREACH0308]
      goto FOREACH0300
    RETURN030D:  preds = [FOREACH0300]
      return
#### end program ####
##### mid-ir: after high-to-mid translation ####
## properties
  GlobalInit HasGlobals HasConsts
## globals
  const int[2] ll036B
  global int[] a1036C
  global real[] a2036D
## functions
## input initialization
  ENTRY036E:  preds = []
    int _t036F#2 = 2;
    int[2] ll0371#1 = <int[2]>{_t036F,_t036F};
    globals.ll036B = ll0371;
    return
## global-variable initialization
  ENTRY0375:  preds = []
    int _t0376#1 = 0;
    int _t0378#1 = 10;
    int[] _t037A#2 = Range(_t0376,_t0378);
    int[] accum037C#1 = <int[]>{};
  FOREACH037F:  preds = [ASSIGN037D,NEXT0387]
    foreach (j037E in _t037A) on exit goto ASSIGN0389
      int[] accum0385#2 = phi(accum037C,accum0384)
    int _t0380#1 = 1;
    int _t0382#1 = IAdd(_t0380,j037E);
    int[] accum0384#1 = Append<int>(accum0385,_t0382);
    goto FOREACH037F
  ASSIGN0389:  preds = [FOREACH037F]
    int[] accum0388#1 = <int[]>{};
  FOREACH038B:  preds = [ASSIGN0389,NEXT0393]
    foreach (k038A in accum0385) on exit goto GASSIGN0394
      int[] accum0391#2 = phi(accum0388,accum0390)
    int _t038C#1 = 2;
    int _t038E#1 = IAdd(k038A,_t038C);
    int[] accum0390#1 = Append<int>(accum0391,_t038E);
    goto FOREACH038B
  GASSIGN0394:  preds = [FOREACH038B]
    globals.a1036C = accum0391;
    real[] accum0395#1 = <real[]>{};
  FOREACH0398:  preds = [ASSIGN0396,NEXT03A2]
    foreach (j0397 in _t037A) on exit goto ASSIGN03A4
      real[] accum03A0#2 = phi(accum0395,accum039F)
    real _t0399#1 = 0.1e1;
    real _t039B#1 = IntToReal(j0397);
    real _t039D#1 = λ(T0[],T1[])<(T0 + T1)> (_t0399,_t039B);
    real[] accum039F#1 = Append<real>(accum03A0,_t039D);
    goto FOREACH0398
  ASSIGN03A4:  preds = [FOREACH0398]
    real[] accum03A3#1 = <real[]>{};
  FOREACH03A6:  preds = [ASSIGN03A4,NEXT03AE]
    foreach (k03A5 in accum03A0) on exit goto GASSIGN03AF
      real[] accum03AC#2 = phi(accum03A3,accum03AB)
    real _t03A7#1 = 0.2e1;
    real _t03A9#1 = λ(T0[],T1[])<(T0 + T1)> (k03A5,_t03A7);
    real[] accum03AB#1 = Append<real>(accum03AC,_t03A9);
    goto FOREACH03A6
  GASSIGN03AF:  preds = [FOREACH03A6]
    globals.a2036D = accum03AC;
    return
## strand
  strand gg (int i03B1#2, int j03B2#1)
    state:
      output real result;
      int i;
      int j;
    state init
      ENTRY03B6:  preds = []
        real _t03B7#1 = 0.1e1;
        real _t03B9#1 = IntToReal(i03B1);
        real result03BB#1 = λ(T0[],T1[])<(T0 * T1)> (_t03B7,_t03B9);
        self.result = result03BB;
        self.i = i03B1;
        self.j = j03B2;
        return
    end state init
    method update
        ENTRY03C1:  preds = []
          int[2] ll03C2#2 = globals.ll036B;
          int[] a103C4#2 = globals.a1036C;
          real[] a203C6#1 = globals.a2036D;
          real result03C8#1 = self.result;
          int i03CA#1 = self.i;
          int j03CC#1 = self.j;
          int _t03CE#1 = 10;
          int _t03D0#1 = IMul(i03CA,_t03CE);
          real _t03D2#1 = IntToReal(_t03D0);
          real _t03D4#2 = λ(T0[],T1[])<(T0 * T1)> (result03C8,_t03D2);
          int _t03D6#1 = 0;
          int _t03D8#1 = Subscript<int[2]>(ll03C2,_t03D6);
          string _t03DA#1 = " ! ";
          int _t03DC#1 = 1;
          int _t03DE#1 = Subscript<int[2]>(ll03C2,_t03DC);
          string _t03E0#1 = "bah\n";
          Print<[int,string,int,string]>(_t03D8,_t03DA,_t03DE,_t03E0);
          string _t03E3#5 = "\n";
          string _t03E5#1 = "numCell:";
          int _t03E7#1 = 2;
          real _t03E9#1 = 0.2e1;
          Print<[int[]]>(a103C4);
          Print<[real,string,string,int,string,int[],real[],string,real,string,int,string]>(_t03D4,_t03E3,_t03E5,_t03E7,_t03E3,a103C4,a203C6,_t03E3,_t03E9,_t03E3,j03CC,_t03E3);
          self.result = _t03D4;
          stabilize
    end update
  end gg
## initial strand creation
  COLLECTION
    ENTRY03F0:  preds = []
      int[] a103F1#1 = globals.a1036C;
    FOREACH03F4:  preds = [ASSIGN03F2,NEXT03FF]
      foreach (j03F3 in a103F1) on exit goto RETURN0400
      int _t03F5#1 = 5;
      int _t03F7#1 = 11;
      int[] _t03F9#1 = Range(_t03F5,_t03F7);
    FOREACH03FC:  preds = [ASSIGN03FA,NEXT03FE]
      foreach (k03FB in _t03F9) on exit goto NEXT03FF
      new gg(j03F3,k03FB);
      goto FOREACH03FC
    NEXT03FF:  preds = [FOREACH03FC]
      goto FOREACH03F4
    RETURN0400:  preds = [FOREACH03F4]
      return
#### end program ####
##### mid-ir: after value numbering ####
## properties
  GlobalInit HasGlobals HasConsts
## globals
  const int[2] ll036B
  global int[] a1036C
  global real[] a2036D
## functions
## input initialization
  ENTRY036E:  preds = []
    int _t036F#2 = 2;
    int[2] ll0371#1 = <int[2]>{_t036F,_t036F};
    globals.ll036B = ll0371;
    return
## global-variable initialization
  ENTRY0375:  preds = []
    int _t0376#1 = 0;
    int _t0378#1 = 10;
    int[] _t037A#2 = Range(_t0376,_t0378);
    int[] accum037C#1 = <int[]>{};
  FOREACH037F:  preds = [ASSIGN037D,NEXT0387]
    foreach (j037E in _t037A) on exit goto ASSIGN0389
      int[] accum0385#2 = phi(accum037C,accum0384)
    int _t0380#1 = 1;
    int _t0382#1 = IAdd(_t0380,j037E);
    int[] accum0384#1 = Append<int>(accum0385,_t0382);
    goto FOREACH037F
  ASSIGN0389:  preds = [FOREACH037F]
    int[] accum0388#1 = <int[]>{};
  FOREACH038B:  preds = [ASSIGN0389,NEXT0393]
    foreach (k038A in accum0385) on exit goto GASSIGN0394
      int[] accum0391#2 = phi(accum0388,accum0390)
    int _t038C#1 = 2;
    int _t038E#1 = IAdd(k038A,_t038C);
    int[] accum0390#1 = Append<int>(accum0391,_t038E);
    goto FOREACH038B
  GASSIGN0394:  preds = [FOREACH038B]
    globals.a1036C = accum0391;
    real[] accum0395#1 = <real[]>{};
  FOREACH0398:  preds = [ASSIGN0396,NEXT03A2]
    foreach (j0397 in _t037A) on exit goto ASSIGN03A4
      real[] accum03A0#2 = phi(accum0395,accum039F)
    real _t0399#1 = 0.1e1;
    real _t039B#1 = IntToReal(j0397);
    real _t039D#1 = λ(T0[],T1[])<(T0 + T1)> (_t0399,_t039B);
    real[] accum039F#1 = Append<real>(accum03A0,_t039D);
    goto FOREACH0398
  ASSIGN03A4:  preds = [FOREACH0398]
    real[] accum03A3#1 = <real[]>{};
  FOREACH03A6:  preds = [ASSIGN03A4,NEXT03AE]
    foreach (k03A5 in accum03A0) on exit goto GASSIGN03AF
      real[] accum03AC#2 = phi(accum03A3,accum03AB)
    real _t03A7#1 = 0.2e1;
    real _t03A9#1 = λ(T0[],T1[])<(T0 + T1)> (k03A5,_t03A7);
    real[] accum03AB#1 = Append<real>(accum03AC,_t03A9);
    goto FOREACH03A6
  GASSIGN03AF:  preds = [FOREACH03A6]
    globals.a2036D = accum03AC;
    return
## strand
  strand gg (int i03B1#2, int j03B2#1)
    state:
      output real result;
      int i;
      int j;
    state init
      ENTRY03B6:  preds = []
        real _t03B7#1 = 0.1e1;
        real _t03B9#1 = IntToReal(i03B1);
        real result03BB#1 = λ(T0[],T1[])<(T0 * T1)> (_t03B7,_t03B9);
        self.result = result03BB;
        self.i = i03B1;
        self.j = j03B2;
        return
    end state init
    method update
        ENTRY03C1:  preds = []
          int[2] ll03C2#2 = globals.ll036B;
          int[] a103C4#2 = globals.a1036C;
          real[] a203C6#1 = globals.a2036D;
          real result03C8#1 = self.result;
          int i03CA#1 = self.i;
          int j03CC#1 = self.j;
          int _t03CE#1 = 10;
          int _t03D0#1 = IMul(i03CA,_t03CE);
          real _t03D2#1 = IntToReal(_t03D0);
          real _t03D4#2 = λ(T0[],T1[])<(T0 * T1)> (result03C8,_t03D2);
          int _t03D6#1 = 0;
          int _t03D8#1 = Subscript<int[2]>(ll03C2,_t03D6);
          string _t03DA#1 = " ! ";
          int _t03DC#1 = 1;
          int _t03DE#1 = Subscript<int[2]>(ll03C2,_t03DC);
          string _t03E0#1 = "bah\n";
          Print<[int,string,int,string]>(_t03D8,_t03DA,_t03DE,_t03E0);
          string _t03E3#5 = "\n";
          string _t03E5#1 = "numCell:";
          int _t03E7#1 = 2;
          real _t03E9#1 = 0.2e1;
          Print<[int[]]>(a103C4);
          Print<[real,string,string,int,string,int[],real[],string,real,string,int,string]>(_t03D4,_t03E3,_t03E5,_t03E7,_t03E3,a103C4,a203C6,_t03E3,_t03E9,_t03E3,j03CC,_t03E3);
          self.result = _t03D4;
          stabilize
    end update
  end gg
## initial strand creation
  COLLECTION
    ENTRY03F0:  preds = []
      int[] a103F1#1 = globals.a1036C;
    FOREACH03F4:  preds = [ASSIGN03F2,NEXT03FF]
      foreach (j03F3 in a103F1) on exit goto RETURN0400
      int _t03F5#1 = 5;
      int _t03F7#1 = 11;
      int[] _t03F9#1 = Range(_t03F5,_t03F7);
    FOREACH03FC:  preds = [ASSIGN03FA,NEXT03FE]
      foreach (k03FB in _t03F9) on exit goto NEXT03FF
      new gg(j03F3,k03FB);
      goto FOREACH03FC
    NEXT03FF:  preds = [FOREACH03FC]
      goto FOREACH03F4
    RETURN0400:  preds = [FOREACH03F4]
      return
#### end program ####
##### mid-ir: after contraction ####
## properties
  GlobalInit HasGlobals HasConsts
## globals
  const int[2] ll036B
  global int[] a1036C
  global real[] a2036D
## functions
## input initialization
  ENTRY036E:  preds = []
    int _t036F#2 = 2;
    int[2] ll0371#1 = <int[2]>{_t036F,_t036F};
    globals.ll036B = ll0371;
    return
## global-variable initialization
  ENTRY0375:  preds = []
    int _t0376#1 = 0;
    int _t0378#1 = 10;
    int[] _t037A#2 = Range(_t0376,_t0378);
    int[] accum037C#1 = <int[]>{};
  FOREACH037F:  preds = [ASSIGN037D,NEXT0387]
    foreach (j037E in _t037A) on exit goto ASSIGN0389
      int[] accum0385#2 = phi(accum037C,accum0384)
    int _t0380#1 = 1;
    int _t0382#1 = IAdd(_t0380,j037E);
    int[] accum0384#1 = Append<int>(accum0385,_t0382);
    goto FOREACH037F
  ASSIGN0389:  preds = [FOREACH037F]
    int[] accum0388#1 = <int[]>{};
  FOREACH038B:  preds = [ASSIGN0389,NEXT0393]
    foreach (k038A in accum0385) on exit goto GASSIGN0394
      int[] accum0391#2 = phi(accum0388,accum0390)
    int _t038C#1 = 2;
    int _t038E#1 = IAdd(k038A,_t038C);
    int[] accum0390#1 = Append<int>(accum0391,_t038E);
    goto FOREACH038B
  GASSIGN0394:  preds = [FOREACH038B]
    globals.a1036C = accum0391;
    real[] accum0395#1 = <real[]>{};
  FOREACH0398:  preds = [ASSIGN0396,NEXT03A2]
    foreach (j0397 in _t037A) on exit goto ASSIGN03A4
      real[] accum03A0#2 = phi(accum0395,accum039F)
    real _t0399#1 = 0.1e1;
    real _t039B#1 = IntToReal(j0397);
    real _t039D#1 = λ(T0[],T1[])<(T0 + T1)> (_t0399,_t039B);
    real[] accum039F#1 = Append<real>(accum03A0,_t039D);
    goto FOREACH0398
  ASSIGN03A4:  preds = [FOREACH0398]
    real[] accum03A3#1 = <real[]>{};
  FOREACH03A6:  preds = [ASSIGN03A4,NEXT03AE]
    foreach (k03A5 in accum03A0) on exit goto GASSIGN03AF
      real[] accum03AC#2 = phi(accum03A3,accum03AB)
    real _t03A7#1 = 0.2e1;
    real _t03A9#1 = λ(T0[],T1[])<(T0 + T1)> (k03A5,_t03A7);
    real[] accum03AB#1 = Append<real>(accum03AC,_t03A9);
    goto FOREACH03A6
  GASSIGN03AF:  preds = [FOREACH03A6]
    globals.a2036D = accum03AC;
    return
## strand
  strand gg (int i03B1#2, int j03B2#1)
    state:
      output real result;
      int i;
      int j;
    state init
      ENTRY03B6:  preds = []
        real _t03B7#1 = 0.1e1;
        real _t03B9#1 = IntToReal(i03B1);
        real result03BB#1 = λ(T0[],T1[])<(T0 * T1)> (_t03B7,_t03B9);
        self.result = result03BB;
        self.i = i03B1;
        self.j = j03B2;
        return
    end state init
    method update
        ENTRY03C1:  preds = []
          int[2] ll03C2#2 = globals.ll036B;
          int[] a103C4#2 = globals.a1036C;
          real[] a203C6#1 = globals.a2036D;
          real result03C8#1 = self.result;
          int i03CA#1 = self.i;
          int j03CC#1 = self.j;
          int _t03CE#1 = 10;
          int _t03D0#1 = IMul(i03CA,_t03CE);
          real _t03D2#1 = IntToReal(_t03D0);
          real _t03D4#2 = λ(T0[],T1[])<(T0 * T1)> (result03C8,_t03D2);
          int _t03D6#1 = 0;
          int _t03D8#1 = Subscript<int[2]>(ll03C2,_t03D6);
          string _t03DA#1 = " ! ";
          int _t03DC#1 = 1;
          int _t03DE#1 = Subscript<int[2]>(ll03C2,_t03DC);
          string _t03E0#1 = "bah\n";
          Print<[int,string,int,string]>(_t03D8,_t03DA,_t03DE,_t03E0);
          string _t03E3#5 = "\n";
          string _t03E5#1 = "numCell:";
          int _t03E7#1 = 2;
          real _t03E9#1 = 0.2e1;
          Print<[int[]]>(a103C4);
          Print<[real,string,string,int,string,int[],real[],string,real,string,int,string]>(_t03D4,_t03E3,_t03E5,_t03E7,_t03E3,a103C4,a203C6,_t03E3,_t03E9,_t03E3,j03CC,_t03E3);
          self.result = _t03D4;
          stabilize
    end update
  end gg
## initial strand creation
  COLLECTION
    ENTRY03F0:  preds = []
      int[] a103F1#1 = globals.a1036C;
    FOREACH03F4:  preds = [ASSIGN03F2,NEXT03FF]
      foreach (j03F3 in a103F1) on exit goto RETURN0400
      int _t03F5#1 = 5;
      int _t03F7#1 = 11;
      int[] _t03F9#1 = Range(_t03F5,_t03F7);
    FOREACH03FC:  preds = [ASSIGN03FA,NEXT03FE]
      foreach (k03FB in _t03F9) on exit goto NEXT03FF
      new gg(j03F3,k03FB);
      goto FOREACH03FC
    NEXT03FF:  preds = [FOREACH03FC]
      goto FOREACH03F4
    RETURN0400:  preds = [FOREACH03F4]
      return
#### end program ####
##### mid-ir: after border control ####
## properties
  GlobalInit HasGlobals HasConsts
## globals
  const int[2] ll036B
  global int[] a1036C
  global real[] a2036D
## functions
## input initialization
  ENTRY036E:  preds = []
    int _t036F#2 = 2;
    int[2] ll0371#1 = <int[2]>{_t036F,_t036F};
    globals.ll036B = ll0371;
    return
## global-variable initialization
  ENTRY0375:  preds = []
    int _t0376#1 = 0;
    int _t0378#1 = 10;
    int[] _t037A#2 = Range(_t0376,_t0378);
    int[] accum037C#1 = <int[]>{};
  FOREACH037F:  preds = [ASSIGN037D,NEXT0387]
    foreach (j037E in _t037A) on exit goto ASSIGN0389
      int[] accum0385#2 = phi(accum037C,accum0384)
    int _t0380#1 = 1;
    int _t0382#1 = IAdd(_t0380,j037E);
    int[] accum0384#1 = Append<int>(accum0385,_t0382);
    goto FOREACH037F
  ASSIGN0389:  preds = [FOREACH037F]
    int[] accum0388#1 = <int[]>{};
  FOREACH038B:  preds = [ASSIGN0389,NEXT0393]
    foreach (k038A in accum0385) on exit goto GASSIGN0394
      int[] accum0391#2 = phi(accum0388,accum0390)
    int _t038C#1 = 2;
    int _t038E#1 = IAdd(k038A,_t038C);
    int[] accum0390#1 = Append<int>(accum0391,_t038E);
    goto FOREACH038B
  GASSIGN0394:  preds = [FOREACH038B]
    globals.a1036C = accum0391;
    real[] accum0395#1 = <real[]>{};
  FOREACH0398:  preds = [ASSIGN0396,NEXT03A2]
    foreach (j0397 in _t037A) on exit goto ASSIGN03A4
      real[] accum03A0#2 = phi(accum0395,accum039F)
    real _t0399#1 = 0.1e1;
    real _t039B#1 = IntToReal(j0397);
    real _t039D#1 = λ(T0[],T1[])<(T0 + T1)> (_t0399,_t039B);
    real[] accum039F#1 = Append<real>(accum03A0,_t039D);
    goto FOREACH0398
  ASSIGN03A4:  preds = [FOREACH0398]
    real[] accum03A3#1 = <real[]>{};
  FOREACH03A6:  preds = [ASSIGN03A4,NEXT03AE]
    foreach (k03A5 in accum03A0) on exit goto GASSIGN03AF
      real[] accum03AC#2 = phi(accum03A3,accum03AB)
    real _t03A7#1 = 0.2e1;
    real _t03A9#1 = λ(T0[],T1[])<(T0 + T1)> (k03A5,_t03A7);
    real[] accum03AB#1 = Append<real>(accum03AC,_t03A9);
    goto FOREACH03A6
  GASSIGN03AF:  preds = [FOREACH03A6]
    globals.a2036D = accum03AC;
    return
## strand
  strand gg (int i03B1#2, int j03B2#1)
    state:
      output real result;
      int i;
      int j;
    state init
      ENTRY03B6:  preds = []
        real _t03B7#1 = 0.1e1;
        real _t03B9#1 = IntToReal(i03B1);
        real result03BB#1 = λ(T0[],T1[])<(T0 * T1)> (_t03B7,_t03B9);
        self.result = result03BB;
        self.i = i03B1;
        self.j = j03B2;
        return
    end state init
    method update
        ENTRY03C1:  preds = []
          int[2] ll03C2#2 = globals.ll036B;
          int[] a103C4#2 = globals.a1036C;
          real[] a203C6#1 = globals.a2036D;
          real result03C8#1 = self.result;
          int i03CA#1 = self.i;
          int j03CC#1 = self.j;
          int _t03CE#1 = 10;
          int _t03D0#1 = IMul(i03CA,_t03CE);
          real _t03D2#1 = IntToReal(_t03D0);
          real _t03D4#2 = λ(T0[],T1[])<(T0 * T1)> (result03C8,_t03D2);
          int _t03D6#1 = 0;
          int _t03D8#1 = Subscript<int[2]>(ll03C2,_t03D6);
          string _t03DA#1 = " ! ";
          int _t03DC#1 = 1;
          int _t03DE#1 = Subscript<int[2]>(ll03C2,_t03DC);
          string _t03E0#1 = "bah\n";
          Print<[int,string,int,string]>(_t03D8,_t03DA,_t03DE,_t03E0);
          string _t03E3#5 = "\n";
          string _t03E5#1 = "numCell:";
          int _t03E7#1 = 2;
          real _t03E9#1 = 0.2e1;
          Print<[int[]]>(a103C4);
          Print<[real,string,string,int,string,int[],real[],string,real,string,int,string]>(_t03D4,_t03E3,_t03E5,_t03E7,_t03E3,a103C4,a203C6,_t03E3,_t03E9,_t03E3,j03CC,_t03E3);
          self.result = _t03D4;
          stabilize
    end update
  end gg
## initial strand creation
  COLLECTION
    ENTRY03F0:  preds = []
      int[] a103F1#1 = globals.a1036C;
    FOREACH03F4:  preds = [ASSIGN03F2,NEXT03FF]
      foreach (j03F3 in a103F1) on exit goto RETURN0400
      int _t03F5#1 = 5;
      int _t03F7#1 = 11;
      int[] _t03F9#1 = Range(_t03F5,_t03F7);
    FOREACH03FC:  preds = [ASSIGN03FA,NEXT03FE]
      foreach (k03FB in _t03F9) on exit goto NEXT03FF
      new gg(j03F3,k03FB);
      goto FOREACH03FC
    NEXT03FF:  preds = [FOREACH03FC]
      goto FOREACH03F4
    RETURN0400:  preds = [FOREACH03F4]
      return
#### end program ####
##### low-ir: after mid-to-low translation ####
## properties
  GlobalInit HasGlobals HasConsts
## globals
  const int[2] ll0401
  global int[] a10402
  global real[] a20403
## functions
## input initialization
  ENTRY0404:  preds = []
    int _t0405#2 = 2;
    int[2] ll0407#1 = <int[2]>{_t0405,_t0405};
    globals.ll0401 = ll0407;
    return
## global-variable initialization
  ENTRY040B:  preds = []
    int _t040C#1 = 0;
    int _t040E#1 = 10;
    int[] _t0410#2 = Range(_t040C,_t040E);
    int[] accum0412#1 = <int[]>{};
  FOREACH0415:  preds = [ASSIGN0413,NEXT041D]
    foreach (j0414 in _t0410) on exit goto ASSIGN041F
      int[] accum041B#2 = phi(accum0412,accum041A)
    int _t0416#1 = 1;
    int _t0418#1 = IAdd(_t0416,j0414);
    int[] accum041A#1 = Append<int>(accum041B,_t0418);
    goto FOREACH0415
  ASSIGN041F:  preds = [FOREACH0415]
    int[] accum041E#1 = <int[]>{};
  FOREACH0421:  preds = [ASSIGN041F,NEXT0429]
    foreach (k0420 in accum041B) on exit goto GASSIGN042A
      int[] accum0427#2 = phi(accum041E,accum0426)
    int _t0422#1 = 2;
    int _t0424#1 = IAdd(k0420,_t0422);
    int[] accum0426#1 = Append<int>(accum0427,_t0424);
    goto FOREACH0421
  GASSIGN042A:  preds = [FOREACH0421]
    globals.a10402 = accum0427;
    real[] accum042B#1 = <real[]>{};
  FOREACH042E:  preds = [ASSIGN042C,NEXT0439]
    foreach (j042D in _t0410) on exit goto ASSIGN043B
      real[] accum0437#2 = phi(accum042B,accum0436)
    real _t042F#1 = 0.1e1;
    real _t0431#1 = IntToReal(j042D);
    real _t0433#1 = RAdd(_t042F,_t0431);
    real[] accum0436#1 = Append<real>(accum0437,_t0433);
    goto FOREACH042E
  ASSIGN043B:  preds = [FOREACH042E]
    real[] accum043A#1 = <real[]>{};
  FOREACH043D:  preds = [ASSIGN043B,NEXT0446]
    foreach (k043C in accum0437) on exit goto GASSIGN0447
      real[] accum0444#2 = phi(accum043A,accum0443)
    real _t043E#1 = 0.2e1;
    real _t0440#1 = RAdd(k043C,_t043E);
    real[] accum0443#1 = Append<real>(accum0444,_t0440);
    goto FOREACH043D
  GASSIGN0447:  preds = [FOREACH043D]
    globals.a20403 = accum0444;
    return
## strand
  strand gg (int i0449#2, int j044A#1)
    state:
      output real result;
      int i;
      int j;
    state init
      ENTRY044E:  preds = []
        real _t044F#1 = 0.1e1;
        real _t0451#1 = IntToReal(i0449);
        real result0453#1 = RMul(_t044F,_t0451);
        self.result = result0453;
        self.i = i0449;
        self.j = j044A;
        return
    end state init
    method update
        ENTRY045A:  preds = []
          int[2] ll045B#2 = globals.ll0401;
          int[] a1045D#2 = globals.a10402;
          real[] a2045F#1 = globals.a20403;
          real result0461#1 = self.result;
          int i0463#1 = self.i;
          int j0465#1 = self.j;
          int _t0467#1 = 10;
          int _t0469#1 = IMul(i0463,_t0467);
          real _t046B#1 = IntToReal(_t0469);
          real _t046D#2 = RMul(result0461,_t046B);
          int _t0470#1 = 0;
          int _t0472#1 = Subscript<int[2]>(ll045B,_t0470);
          string _t0474#1 = " ! ";
          int _t0476#1 = 1;
          int _t0478#1 = Subscript<int[2]>(ll045B,_t0476);
          string _t047A#1 = "bah\n";
          Print<[int,string,int,string]>(_t0472,_t0474,_t0478,_t047A);
          string _t047D#5 = "\n";
          string _t047F#1 = "numCell:";
          int _t0481#1 = 2;
          real _t0483#1 = 0.2e1;
          Print<[int[]]>(a1045D);
          Print<[real,string,string,int,string,int[],real[],string,real,string,int,string]>(_t046D,_t047D,_t047F,_t0481,_t047D,a1045D,a2045F,_t047D,_t0483,_t047D,j0465,_t047D);
          self.result = _t046D;
          stabilize
    end update
  end gg
## initial strand creation
  COLLECTION
    ENTRY048A:  preds = []
      int[] a1048B#1 = globals.a10402;
    FOREACH048E:  preds = [ASSIGN048C,NEXT0499]
      foreach (j048D in a1048B) on exit goto RETURN049A
      int _t048F#1 = 5;
      int _t0491#1 = 11;
      int[] _t0493#1 = Range(_t048F,_t0491);
    FOREACH0496:  preds = [ASSIGN0494,NEXT0498]
      foreach (k0495 in _t0493) on exit goto NEXT0499
      new gg(j048D,k0495);
      goto FOREACH0496
    NEXT0499:  preds = [FOREACH0496]
      goto FOREACH048E
    RETURN049A:  preds = [FOREACH048E]
      return
#### end program ####
##### low-ir: after contraction(1) ####
## properties
  GlobalInit HasGlobals HasConsts
## globals
  const int[2] ll0401
  global int[] a10402
  global real[] a20403
## functions
## input initialization
  ENTRY0404:  preds = []
    int _t0405#2 = 2;
    int[2] ll0407#1 = <int[2]>{_t0405,_t0405};
    globals.ll0401 = ll0407;
    return
## global-variable initialization
  ENTRY040B:  preds = []
    int _t040C#1 = 0;
    int _t040E#1 = 10;
    int[] _t0410#2 = Range(_t040C,_t040E);
    int[] accum0412#1 = <int[]>{};
  FOREACH0415:  preds = [ASSIGN0413,NEXT041D]
    foreach (j0414 in _t0410) on exit goto ASSIGN041F
      int[] accum041B#2 = phi(accum0412,accum041A)
    int _t0416#1 = 1;
    int _t0418#1 = IAdd(_t0416,j0414);
    int[] accum041A#1 = Append<int>(accum041B,_t0418);
    goto FOREACH0415
  ASSIGN041F:  preds = [FOREACH0415]
    int[] accum041E#1 = <int[]>{};
  FOREACH0421:  preds = [ASSIGN041F,NEXT0429]
    foreach (k0420 in accum041B) on exit goto GASSIGN042A
      int[] accum0427#2 = phi(accum041E,accum0426)
    int _t0422#1 = 2;
    int _t0424#1 = IAdd(k0420,_t0422);
    int[] accum0426#1 = Append<int>(accum0427,_t0424);
    goto FOREACH0421
  GASSIGN042A:  preds = [FOREACH0421]
    globals.a10402 = accum0427;
    real[] accum042B#1 = <real[]>{};
  FOREACH042E:  preds = [ASSIGN042C,NEXT0439]
    foreach (j042D in _t0410) on exit goto ASSIGN043B
      real[] accum0437#2 = phi(accum042B,accum0436)
    real _t042F#1 = 0.1e1;
    real _t0431#1 = IntToReal(j042D);
    real _t0433#1 = RAdd(_t042F,_t0431);
    real[] accum0436#1 = Append<real>(accum0437,_t0433);
    goto FOREACH042E
  ASSIGN043B:  preds = [FOREACH042E]
    real[] accum043A#1 = <real[]>{};
  FOREACH043D:  preds = [ASSIGN043B,NEXT0446]
    foreach (k043C in accum0437) on exit goto GASSIGN0447
      real[] accum0444#2 = phi(accum043A,accum0443)
    real _t043E#1 = 0.2e1;
    real _t0440#1 = RAdd(k043C,_t043E);
    real[] accum0443#1 = Append<real>(accum0444,_t0440);
    goto FOREACH043D
  GASSIGN0447:  preds = [FOREACH043D]
    globals.a20403 = accum0444;
    return
## strand
  strand gg (int i0449#2, int j044A#1)
    state:
      output real result;
      int i;
      int j;
    state init
      ENTRY044E:  preds = []
        real _t044F#1 = 0.1e1;
        real _t0451#1 = IntToReal(i0449);
        real result0453#1 = RMul(_t044F,_t0451);
        self.result = result0453;
        self.i = i0449;
        self.j = j044A;
        return
    end state init
    method update
        ENTRY045A:  preds = []
          int[2] ll045B#2 = globals.ll0401;
          int[] a1045D#2 = globals.a10402;
          real[] a2045F#1 = globals.a20403;
          real result0461#1 = self.result;
          int i0463#1 = self.i;
          int j0465#1 = self.j;
          int _t0467#1 = 10;
          int _t0469#1 = IMul(i0463,_t0467);
          real _t046B#1 = IntToReal(_t0469);
          real _t046D#2 = RMul(result0461,_t046B);
          int _t0470#1 = 0;
          int _t0472#1 = Subscript<int[2]>(ll045B,_t0470);
          string _t0474#1 = " ! ";
          int _t0476#1 = 1;
          int _t0478#1 = Subscript<int[2]>(ll045B,_t0476);
          string _t047A#1 = "bah\n";
          Print<[int,string,int,string]>(_t0472,_t0474,_t0478,_t047A);
          string _t047D#5 = "\n";
          string _t047F#1 = "numCell:";
          int _t0481#1 = 2;
          real _t0483#1 = 0.2e1;
          Print<[int[]]>(a1045D);
          Print<[real,string,string,int,string,int[],real[],string,real,string,int,string]>(_t046D,_t047D,_t047F,_t0481,_t047D,a1045D,a2045F,_t047D,_t0483,_t047D,j0465,_t047D);
          self.result = _t046D;
          stabilize
    end update
  end gg
## initial strand creation
  COLLECTION
    ENTRY048A:  preds = []
      int[] a1048B#1 = globals.a10402;
    FOREACH048E:  preds = [ASSIGN048C,NEXT0499]
      foreach (j048D in a1048B) on exit goto RETURN049A
      int _t048F#1 = 5;
      int _t0491#1 = 11;
      int[] _t0493#1 = Range(_t048F,_t0491);
    FOREACH0496:  preds = [ASSIGN0494,NEXT0498]
      foreach (k0495 in _t0493) on exit goto NEXT0499
      new gg(j048D,k0495);
      goto FOREACH0496
    NEXT0499:  preds = [FOREACH0496]
      goto FOREACH048E
    RETURN049A:  preds = [FOREACH048E]
      return
#### end program ####
##### low-ir: after value numbering ####
## properties
  GlobalInit HasGlobals HasConsts
## globals
  const int[2] ll0401
  global int[] a10402
  global real[] a20403
## functions
## input initialization
  ENTRY0404:  preds = []
    int _t0405#2 = 2;
    int[2] ll0407#1 = <int[2]>{_t0405,_t0405};
    globals.ll0401 = ll0407;
    return
## global-variable initialization
  ENTRY040B:  preds = []
    int _t040C#1 = 0;
    int _t040E#1 = 10;
    int[] _t0410#2 = Range(_t040C,_t040E);
    int[] accum0412#1 = <int[]>{};
  FOREACH0415:  preds = [ASSIGN0413,NEXT041D]
    foreach (j0414 in _t0410) on exit goto ASSIGN041F
      int[] accum041B#2 = phi(accum0412,accum041A)
    int _t0416#1 = 1;
    int _t0418#1 = IAdd(_t0416,j0414);
    int[] accum041A#1 = Append<int>(accum041B,_t0418);
    goto FOREACH0415
  ASSIGN041F:  preds = [FOREACH0415]
    int[] accum041E#1 = <int[]>{};
  FOREACH0421:  preds = [ASSIGN041F,NEXT0429]
    foreach (k0420 in accum041B) on exit goto GASSIGN042A
      int[] accum0427#2 = phi(accum041E,accum0426)
    int _t0422#1 = 2;
    int _t0424#1 = IAdd(k0420,_t0422);
    int[] accum0426#1 = Append<int>(accum0427,_t0424);
    goto FOREACH0421
  GASSIGN042A:  preds = [FOREACH0421]
    globals.a10402 = accum0427;
    real[] accum042B#1 = <real[]>{};
  FOREACH042E:  preds = [ASSIGN042C,NEXT0439]
    foreach (j042D in _t0410) on exit goto ASSIGN043B
      real[] accum0437#2 = phi(accum042B,accum0436)
    real _t042F#1 = 0.1e1;
    real _t0431#1 = IntToReal(j042D);
    real _t0433#1 = RAdd(_t042F,_t0431);
    real[] accum0436#1 = Append<real>(accum0437,_t0433);
    goto FOREACH042E
  ASSIGN043B:  preds = [FOREACH042E]
    real[] accum043A#1 = <real[]>{};
  FOREACH043D:  preds = [ASSIGN043B,NEXT0446]
    foreach (k043C in accum0437) on exit goto GASSIGN0447
      real[] accum0444#2 = phi(accum043A,accum0443)
    real _t043E#1 = 0.2e1;
    real _t0440#1 = RAdd(k043C,_t043E);
    real[] accum0443#1 = Append<real>(accum0444,_t0440);
    goto FOREACH043D
  GASSIGN0447:  preds = [FOREACH043D]
    globals.a20403 = accum0444;
    return
## strand
  strand gg (int i0449#2, int j044A#1)
    state:
      output real result;
      int i;
      int j;
    state init
      ENTRY044E:  preds = []
        real _t044F#1 = 0.1e1;
        real _t0451#1 = IntToReal(i0449);
        real result0453#1 = RMul(_t044F,_t0451);
        self.result = result0453;
        self.i = i0449;
        self.j = j044A;
        return
    end state init
    method update
        ENTRY045A:  preds = []
          int[2] ll045B#2 = globals.ll0401;
          int[] a1045D#2 = globals.a10402;
          real[] a2045F#1 = globals.a20403;
          real result0461#1 = self.result;
          int i0463#1 = self.i;
          int j0465#1 = self.j;
          int _t0467#1 = 10;
          int _t0469#1 = IMul(i0463,_t0467);
          real _t046B#1 = IntToReal(_t0469);
          real _t046D#2 = RMul(result0461,_t046B);
          int _t0470#1 = 0;
          int _t0472#1 = Subscript<int[2]>(ll045B,_t0470);
          string _t0474#1 = " ! ";
          int _t0476#1 = 1;
          int _t0478#1 = Subscript<int[2]>(ll045B,_t0476);
          string _t047A#1 = "bah\n";
          Print<[int,string,int,string]>(_t0472,_t0474,_t0478,_t047A);
          string _t047D#5 = "\n";
          string _t047F#1 = "numCell:";
          int _t0481#1 = 2;
          real _t0483#1 = 0.2e1;
          Print<[int[]]>(a1045D);
          Print<[real,string,string,int,string,int[],real[],string,real,string,int,string]>(_t046D,_t047D,_t047F,_t0481,_t047D,a1045D,a2045F,_t047D,_t0483,_t047D,j0465,_t047D);
          self.result = _t046D;
          stabilize
    end update
  end gg
## initial strand creation
  COLLECTION
    ENTRY048A:  preds = []
      int[] a1048B#1 = globals.a10402;
    FOREACH048E:  preds = [ASSIGN048C,NEXT0499]
      foreach (j048D in a1048B) on exit goto RETURN049A
      int _t048F#1 = 5;
      int _t0491#1 = 11;
      int[] _t0493#1 = Range(_t048F,_t0491);
    FOREACH0496:  preds = [ASSIGN0494,NEXT0498]
      foreach (k0495 in _t0493) on exit goto NEXT0499
      new gg(j048D,k0495);
      goto FOREACH0496
    NEXT0499:  preds = [FOREACH0496]
      goto FOREACH048E
    RETURN049A:  preds = [FOREACH048E]
      return
#### end program ####
##### low-ir: after contraction(2) ####
## properties
  GlobalInit HasGlobals HasConsts
## globals
  const int[2] ll0401
  global int[] a10402
  global real[] a20403
## functions
## input initialization
  ENTRY0404:  preds = []
    int _t0405#2 = 2;
    int[2] ll0407#1 = <int[2]>{_t0405,_t0405};
    globals.ll0401 = ll0407;
    return
## global-variable initialization
  ENTRY040B:  preds = []
    int _t040C#1 = 0;
    int _t040E#1 = 10;
    int[] _t0410#2 = Range(_t040C,_t040E);
    int[] accum0412#1 = <int[]>{};
  FOREACH0415:  preds = [ASSIGN0413,NEXT041D]
    foreach (j0414 in _t0410) on exit goto ASSIGN041F
      int[] accum041B#2 = phi(accum0412,accum041A)
    int _t0416#1 = 1;
    int _t0418#1 = IAdd(_t0416,j0414);
    int[] accum041A#1 = Append<int>(accum041B,_t0418);
    goto FOREACH0415
  ASSIGN041F:  preds = [FOREACH0415]
    int[] accum041E#1 = <int[]>{};
  FOREACH0421:  preds = [ASSIGN041F,NEXT0429]
    foreach (k0420 in accum041B) on exit goto GASSIGN042A
      int[] accum0427#2 = phi(accum041E,accum0426)
    int _t0422#1 = 2;
    int _t0424#1 = IAdd(k0420,_t0422);
    int[] accum0426#1 = Append<int>(accum0427,_t0424);
    goto FOREACH0421
  GASSIGN042A:  preds = [FOREACH0421]
    globals.a10402 = accum0427;
    real[] accum042B#1 = <real[]>{};
  FOREACH042E:  preds = [ASSIGN042C,NEXT0439]
    foreach (j042D in _t0410) on exit goto ASSIGN043B
      real[] accum0437#2 = phi(accum042B,accum0436)
    real _t042F#1 = 0.1e1;
    real _t0431#1 = IntToReal(j042D);
    real _t0433#1 = RAdd(_t042F,_t0431);
    real[] accum0436#1 = Append<real>(accum0437,_t0433);
    goto FOREACH042E
  ASSIGN043B:  preds = [FOREACH042E]
    real[] accum043A#1 = <real[]>{};
  FOREACH043D:  preds = [ASSIGN043B,NEXT0446]
    foreach (k043C in accum0437) on exit goto GASSIGN0447
      real[] accum0444#2 = phi(accum043A,accum0443)
    real _t043E#1 = 0.2e1;
    real _t0440#1 = RAdd(k043C,_t043E);
    real[] accum0443#1 = Append<real>(accum0444,_t0440);
    goto FOREACH043D
  GASSIGN0447:  preds = [FOREACH043D]
    globals.a20403 = accum0444;
    return
## strand
  strand gg (int i0449#2, int j044A#1)
    state:
      output real result;
      int i;
      int j;
    state init
      ENTRY044E:  preds = []
        real _t044F#1 = 0.1e1;
        real _t0451#1 = IntToReal(i0449);
        real result0453#1 = RMul(_t044F,_t0451);
        self.result = result0453;
        self.i = i0449;
        self.j = j044A;
        return
    end state init
    method update
        ENTRY045A:  preds = []
          int[2] ll045B#2 = globals.ll0401;
          int[] a1045D#2 = globals.a10402;
          real[] a2045F#1 = globals.a20403;
          real result0461#1 = self.result;
          int i0463#1 = self.i;
          int j0465#1 = self.j;
          int _t0467#1 = 10;
          int _t0469#1 = IMul(i0463,_t0467);
          real _t046B#1 = IntToReal(_t0469);
          real _t046D#2 = RMul(result0461,_t046B);
          int _t0470#1 = 0;
          int _t0472#1 = Subscript<int[2]>(ll045B,_t0470);
          string _t0474#1 = " ! ";
          int _t0476#1 = 1;
          int _t0478#1 = Subscript<int[2]>(ll045B,_t0476);
          string _t047A#1 = "bah\n";
          Print<[int,string,int,string]>(_t0472,_t0474,_t0478,_t047A);
          string _t047D#5 = "\n";
          string _t047F#1 = "numCell:";
          int _t0481#1 = 2;
          real _t0483#1 = 0.2e1;
          Print<[int[]]>(a1045D);
          Print<[real,string,string,int,string,int[],real[],string,real,string,int,string]>(_t046D,_t047D,_t047F,_t0481,_t047D,a1045D,a2045F,_t047D,_t0483,_t047D,j0465,_t047D);
          self.result = _t046D;
          stabilize
    end update
  end gg
## initial strand creation
  COLLECTION
    ENTRY048A:  preds = []
      int[] a1048B#1 = globals.a10402;
    FOREACH048E:  preds = [ASSIGN048C,NEXT0499]
      foreach (j048D in a1048B) on exit goto RETURN049A
      int _t048F#1 = 5;
      int _t0491#1 = 11;
      int[] _t0493#1 = Range(_t048F,_t0491);
    FOREACH0496:  preds = [ASSIGN0494,NEXT0498]
      foreach (k0495 in _t0493) on exit goto NEXT0499
      new gg(j048D,k0495);
      goto FOREACH0496
    NEXT0499:  preds = [FOREACH0496]
      goto FOREACH048E
    RETURN049A:  preds = [FOREACH048E]
      return
#### end program ####
##### low-ir: after flatten ####
## properties
  GlobalInit HasGlobals HasConsts
## globals
  const int[2] ll0401
  global int[] a10402
  global real[] a20403
## functions
## input initialization
  ENTRY0404:  preds = []
    int _t0405#2 = 2;
    int[2] ll0407#1 = <int[2]>{_t0405,_t0405};
    globals.ll0401 = ll0407;
    return
## global-variable initialization
  ENTRY040B:  preds = []
    int _t040C#2 = 0;
    int _t040E#2 = 10;
    int[] _t0410#1 = Range(_t040C,_t040E);
    int[] accum0412#1 = <int[]>{};
  FOREACH0415:  preds = [ASSIGN0413,NEXT041D]
    foreach (j0414 in _t0410) on exit goto ASSIGN041F
      int[] accum041B#2 = phi(accum0412,accum041A)
    int _t0416#1 = 1;
    int _t0418#1 = IAdd(_t0416,j0414);
    int[] accum041A#1 = Append<int>(accum041B,_t0418);
    goto FOREACH0415
  ASSIGN041F:  preds = [FOREACH0415]
    int[] accum041E#1 = <int[]>{};
  FOREACH0421:  preds = [ASSIGN041F,NEXT0429]
    foreach (k0420 in accum041B) on exit goto GASSIGN042A
      int[] accum0427#2 = phi(accum041E,accum0426)
    int _t0422#1 = 2;
    int _t0424#1 = IAdd(k0420,_t0422);
    int[] accum0426#1 = Append<int>(accum0427,_t0424);
    goto FOREACH0421
  GASSIGN042A:  preds = [FOREACH0421]
    globals.a10402 = accum0427;
    real[] accum042B#1 = <real[]>{};
    int[] _t049B#1 = Range(_t040C,_t040E);
  FOREACH042E:  preds = [ASSIGN049C,NEXT0439]
    foreach (j042D in _t049B) on exit goto ASSIGN043B
      real[] accum0437#2 = phi(accum042B,accum0436)
    real _t042F#1 = 0.1e1;
    real _t0431#1 = IntToReal(j042D);
    real _t0433#1 = RAdd(_t042F,_t0431);
    real[] accum0436#1 = Append<real>(accum0437,_t0433);
    goto FOREACH042E
  ASSIGN043B:  preds = [FOREACH042E]
    real[] accum043A#1 = <real[]>{};
  FOREACH043D:  preds = [ASSIGN043B,NEXT0446]
    foreach (k043C in accum0437) on exit goto GASSIGN0447
      real[] accum0444#2 = phi(accum043A,accum0443)
    real _t043E#1 = 0.2e1;
    real _t0440#1 = RAdd(k043C,_t043E);
    real[] accum0443#1 = Append<real>(accum0444,_t0440);
    goto FOREACH043D
  GASSIGN0447:  preds = [FOREACH043D]
    globals.a20403 = accum0444;
    return
## strand
  strand gg (int i0449#2, int j044A#1)
    state:
      output real result;
      int i;
      int j;
    state init
      ENTRY044E:  preds = []
        real _t044F#1 = 0.1e1;
        real _t0451#1 = IntToReal(i0449);
        real result0453#1 = RMul(_t044F,_t0451);
        self.result = result0453;
        self.i = i0449;
        self.j = j044A;
        return
    end state init
    method update
        ENTRY045A:  preds = []
          int[2] ll045B#2 = globals.ll0401;
          int[] a1045D#2 = globals.a10402;
          real[] a2045F#1 = globals.a20403;
          real result0461#1 = self.result;
          int i0463#1 = self.i;
          int j0465#1 = self.j;
          int _t0467#1 = 10;
          int _t0469#1 = IMul(i0463,_t0467);
          real _t046B#1 = IntToReal(_t0469);
          real _t046D#2 = RMul(result0461,_t046B);
          int _t0470#1 = 0;
          int _t0472#1 = Subscript<int[2]>(ll045B,_t0470);
          string _t0474#1 = " ! ";
          int _t0476#1 = 1;
          int _t0478#1 = Subscript<int[2]>(ll045B,_t0476);
          string _t047A#1 = "bah\n";
          Print<[int,string,int,string]>(_t0472,_t0474,_t0478,_t047A);
          string _t047D#5 = "\n";
          string _t047F#1 = "numCell:";
          int _t0481#1 = 2;
          real _t0483#1 = 0.2e1;
          Print<[int[]]>(a1045D);
          Print<[real,string,string,int,string,int[],real[],string,real,string,int,string]>(_t046D,_t047D,_t047F,_t0481,_t047D,a1045D,a2045F,_t047D,_t0483,_t047D,j0465,_t047D);
          self.result = _t046D;
          stabilize
    end update
  end gg
## initial strand creation
  COLLECTION
    ENTRY048A:  preds = []
      int[] a1048B#1 = globals.a10402;
    FOREACH048E:  preds = [ASSIGN048C,NEXT0499]
      foreach (j048D in a1048B) on exit goto RETURN049A
      int _t048F#1 = 5;
      int _t0491#1 = 11;
      int[] _t0493#1 = Range(_t048F,_t0491);
    FOREACH0496:  preds = [ASSIGN0494,NEXT0498]
      foreach (k0495 in _t0493) on exit goto NEXT0499
      new gg(j048D,k0495);
      goto FOREACH0496
    NEXT0499:  preds = [FOREACH0496]
      goto FOREACH048E
    RETURN049A:  preds = [FOREACH048E]
      return
#### end program ####
##### TreeIR: after low-to-tree translation ####
//***** PROPERTIES *****
  GlobalInit HasGlobals HasConsts
//***** CONSTS *****
global int[2] ll;
//***** INPUTS *****
//***** CONST INIT *****
  {
    globals.ll = <int[2]>{2,2};
  }
//***** GLOBALS *****
global int[] a1;
global real[] a2;
//***** FUNCTIONS *****
//***** GLOBAL VARIABLE INIT *****
  {
    real[] l_accum_6;
    real[] l_accum_4;
    int[] l_accum_2;
    int[] l_accum_0;
    l_accum_0 = <int[]>{};
    for i_j_1 = 0 to 10 {
      l_accum_0 = Append<int,int>(l_accum_0,IAdd(1,i_j_1));
    }
    l_accum_2 = <int[]>{};
    foreach int i_k_3 in l_accum_0 {
      l_accum_2 = Append<int,int>(l_accum_2,IAdd(i_k_3,2));
    }
    globals.a1 = l_accum_2;
    l_accum_4 = <real[]>{};
    for i_j_5 = 0 to 10 {
      l_accum_4 = Append<real,real>(l_accum_4,RAdd(0.1e1,IntToReal(i_j_5)));
    }
    l_accum_6 = <real[]>{};
    foreach real i_k_7 in l_accum_4 {
      l_accum_6 = Append<real,real>(l_accum_6,RAdd(i_k_7,0.2e1));
    }
    globals.a2 = l_accum_6;
  }
//***** STRAND *****
strand gg (int p_i_8,int p_j_9) {
  varying output real result;
  int i;
  int j;
  initialize () {
    self.result = RMul(0.1e1,IntToReal(p_i_8));
    self.i = p_i_8;
    self.j = p_j_9;
  }
  update (world, globals) {
    real l__t_10 = RMul(self.result,IntToReal(IMul(self.i,10)));
    print(Subscript<int[2]>(globals.ll,0)," ! ",Subscript<int[2]>(globals.ll,1),"bah\n");
    print(globals.a1);
    print(l__t_10,"\n","numCell:",2,"\n",globals.a1,globals.a2,"\n",0.2e1,"\n",self.j,"\n");
    self.result = l__t_10;
    stabilize;
  }
}
//***** CREATE COLLECTION *****
  {
    foreach int i_j_11 in globals.a1 {
      for i_k_12 = 5 to 11 {
        new gg(i_j_11,i_k_12);
      }
    }
  }
#### end program ####
##### TreeIR: after contraction ####
//***** PROPERTIES *****
  GlobalInit HasGlobals HasConsts
//***** CONSTS *****
global int[2] ll;
//***** INPUTS *****
//***** CONST INIT *****
  {
    globals.ll = <int[2]>{2,2};
  }
//***** GLOBALS *****
global int[] a1;
global real[] a2;
//***** FUNCTIONS *****
//***** GLOBAL VARIABLE INIT *****
  {
    real[] l_accum_6;
    real[] l_accum_4;
    int[] l_accum_2;
    int[] l_accum_0;
    l_accum_0 = <int[]>{};
    for i_j_1 = 0 to 10 {
      l_accum_0 = Append<int,int>(l_accum_0,IAdd(1,i_j_1));
    }
    l_accum_2 = <int[]>{};
    foreach int i_k_3 in l_accum_0 {
      l_accum_2 = Append<int,int>(l_accum_2,IAdd(i_k_3,2));
    }
    globals.a1 = l_accum_2;
    l_accum_4 = <real[]>{};
    for i_j_5 = 0 to 10 {
      l_accum_4 = Append<real,real>(l_accum_4,RAdd(0.1e1,IntToReal(i_j_5)));
    }
    l_accum_6 = <real[]>{};
    foreach real i_k_7 in l_accum_4 {
      l_accum_6 = Append<real,real>(l_accum_6,RAdd(i_k_7,0.2e1));
    }
    globals.a2 = l_accum_6;
  }
//***** STRAND *****
strand gg (int p_i_8,int p_j_9) {
  varying output real result;
  int i;
  int j;
  initialize () {
    self.result = RMul(0.1e1,IntToReal(p_i_8));
    self.i = p_i_8;
    self.j = p_j_9;
  }
  update (world, globals) {
    real l__t_10 = RMul(self.result,IntToReal(IMul(self.i,10)));
    print(Subscript<int[2]>(globals.ll,0)," ! ",Subscript<int[2]>(globals.ll,1),"bah\n");
    print(globals.a1);
    print(l__t_10,"\n","numCell:",2,"\n",globals.a1,globals.a2,"\n",0.2e1,"\n",self.j,"\n");
    self.result = l__t_10;
    stabilize;
  }
}
//***** CREATE COLLECTION *****
  {
    foreach int i_j_11 in globals.a1 {
      for i_k_12 = 5 to 11 {
        new gg(i_j_11,i_k_12);
      }
    }
  }
#### end program ####
/usr/bin/clang++ -fPIC -m64 -c -Wreturn-type -Wuninitialized -march=native -O3 -DNDEBUG -mavx2 -msse4.2 -I/home/teocollin/gitcode/diderot/include -I/usr/local/include crap.cxx
/usr/bin/clang++ -fPIC -m64 -o crap crap.o /home/teocollin/gitcode/diderot/lib/diderot-rt-seq.o -Wl,-rpath=/usr/local/lib -L/usr/local/lib -lteem -lm
                                       Phase                                         Exclusive    Total  
  compiler ..........................................................................   0.004     1.060
    front end .......................................................................   0.035     0.050
      parser ........................................................................   0.014     0.014
      typechecker ...................................................................   0.002     0.002
      simplify ......................................................................   0.000     0.000
    translate .......................................................................   0.001     0.001
    High IR optimization ............................................................   0.003     0.005
      High IR value numbering .......................................................   0.001     0.001
      High IR normalization .........................................................   0.001     0.001
      High IR checking ..............................................................   0.000     0.000
    High to Mid translation .........................................................   0.001     0.001
    Mid IR optimization .............................................................   0.003     0.004
      Mid IR contraction ............................................................   0.000     0.000
      Mid IR value numbering ........................................................   0.001     0.001
      Mid IR border control .........................................................   0.000     0.000
      Mid IR checking ...............................................................   0.000     0.000
    Mid to Low translation ..........................................................   0.001     0.001
    Low IR optimization .............................................................   0.003     0.004
      Low IR contraction ............................................................   0.000     0.000
      Low IR value numbering ........................................................   0.001     0.001
      Low IR checking ...............................................................   0.000     0.000
    Low to Tree translation .........................................................   0.002     0.002
    Tree IR optimization ............................................................   0.000     0.000
      Tree IR contraction ...........................................................   0.000     0.000
      Tree IR checking ..............................................................   0.000     0.000
    code generation .................................................................   0.006     0.987
      C compiler ....................................................................   0.982     0.982
