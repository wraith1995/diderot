#version 3.0


type mesh mesh_t = file("evalProg.json");
const int dim = mesh_t.dim;
int dimm = dim;
type functionSpace{mesh_t}[] fns_t = file("evalProg.json");
type femFunction{fns_t} func_t = file("evalProg.json");


input mesh_t meshData;
input fns_t space = fns_t(meshData);
input func_t data = func_t(space);

field(dim)[] F = data.F;

input tensor[dim][] ipos;

function tensor[dim] findNormal(position{mesh_t}  pos0){
  cell{func_t} c = data.funcCell(pos0.mc);
  tensor[dim] evalPoint  = pos0.refPos;
  tensor[dim] et = pos0.worldPos();
  tensor[dim] grad = ∇(c.transformedRefField)(evalPoint);
  real a = et[0]^5;
  real b = et[1]^5;
  real cc = et[2]^5;
  real z1 = et[0]^6;
  real z2 = et[1]^6;
  real z3 = et[2]^6;
  real t = z1+z2+z3-1;
  real tp = c.refField(evalPoint);
  tensor[dim] gradp = 6 * [a,b,cc];
  print("Doting:", normalize(grad) • normalize(gradp), "\n");
  if(|normalize(grad) - normalize(gradp)| > 0.000001){
    print("=========\n");

    if(acos(normalize(grad) • normalize(gradp)) * π > 0.1){print("warn\n");}
    print("Error is:", acos(normalize(grad) • normalize(gradp)), "\n");
    print("The ref pos:", evalPoint, "\n");
    print("The world pos:", et, "\n");
    print("Error:",normalize(grad) , normalize(gradp), "\n");
    print("Error in impl:", t, "\n");
    print("Error in ugg:", |t-tp|, "\n");
    print("=========\n");

  }
  else {print("COR\n"); print("Erorr in impl:", t, "\n");
    print("Error in ugg:", |t-tp|, "\n");}
  return(normalize(-gradp));
}

strand normal(position{mesh_t}  pos0, tensor[dim] xp){
  output tensor[dim] normal = zeros[dim];
  update {
    if(pos0.isValid){
      normal = findNormal(pos0);
      
      real temp1 = det(∇⊗(pos0.mc.transform)(pos0.refPos));
      real temp2 = det(∇⊗(pos0.mc.transform)([0,0.1, 0.1]));
      real temp3 = det(∇⊗(pos0.mc.transform)([0.25,0.25, 0.25]));
      //print("Ratios:", temp1/temp2, temp1/temp3, temp2/temp3, "\n");
      //print(pos0.mc, ",");
    }
    else {print("Error at input pos:", xp, "\n");}
    
    stabilize;
  }
}
create_collection {normal(meshData.findPos(x), x) | x in ipos};

  
