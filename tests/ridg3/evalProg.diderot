#version 3.0


type mesh mesh_t = file("evalProg.json");
const int dim = mesh_t.dim;
type functionSpace{mesh_t}[] fns_t = file("evalProg.json");
type femFunction{fns_t} func_t = file("evalProg.json");

input mesh_t meshData;
input fns_t space = fns_t(meshData);
input func_t data = func_t(space);

field(dim)[] F = data.F;

refCell{mesh_t} simplex = meshData.refcell();


input real fStrTh ("Feature strength threshold");
input real fMaskTh ("feature mask threshold") = 0;
input real fBias ("Bias in feature strength computing") = 0.0;
input real tipd ("Target inter-particle distance") = 1.0;/*@\label{line:pbfs-tipd}@*/
/* tipd is the only length or speed variable with data spatial
   units; everything else measures space in units of tipd */
input real mabd ("Min allowed birth distance (> 0.7351)") = 0.75;/*@\label{line:pbfs-mabd}@*/
input real travMax ("Max allowed travel to or on feature") = 10;
input int nfsMax ("Max allowed # feature steps ") = 20;
// these next three control the Gradient Descent in Energy
input real gdeTest ("Scaling in sufficient decrease test") = 0.5;
input real gdeBack ("How to scale stepsize for backtrack") = 0.5;
input real gdeOppor ("Opportunistic stepsize increase") = 1.2;
input real fsEps ("Conv. thresh. on feature step size");
input real geoEps ("Conv. thresh. on system geometry") = 0.1;
input real mvmtEps ("Conv. thresh. on point movement") = 0.01;
input real rpcEps ("Conv. thresh. on recent pop. changes") = 0.01;
input real pcmvEps ("Motion limit before PC") = 0.3;
input real isoval ("Which isosurface to sample") = 0;
input int verb ("Verbosity level") = 0;
input real sfs ("Scaling (<=1 for stability) on fStep") = 0.5;
input real hist ("How history matters for convergence") = 0.5;
// higher hist: slower change, more stringent convergence test
input int pcp ("periodicity of population control (PC)") = 5;
input vec3[] ipos ("Initial point positions");
input int fDim = 2;

function bool insideTest(vec3 x){
  vec3 mid = x - [0.0, 0.0, 0.0];
  bool z = |mid[0]| > 0.1 && |mid[1]| > 0.1 && |mid[2]| > 0.1;
  return(|mid| < 4.0 && |mid| > 3.0);
  return(|mid[0]| <= 5.0 && |mid[1]| <= 5.0 && |mid[2]| <= 5.0);
}



function vec3 grad(vec3 s){
  real x = s[0];
  real y = s[1];
  real z = s[2];
  vec3 g = [2*x*(z)^(2)*cos((x)^(2) + (y)^(2) + (z)^(2)), 2*y*(z)^(2)*cos((x)^(2) + (y)^(2) + (z)^(2)), 2*(z)^(3)*cos((x)^(2) + (y)^(2) + (z)^(2)) + 2*z*sin((x)^(2) + (y)^(2) + (z)^(2))];
  return g;
}

function tensor[3,3] hess(vec3 s){
  real x = s[0];
  real y = s[1];
  real z = s[2];
  tensor[3,3] hess = [[-4*(x)^(2)*(z)^(2)*sin((x)^(2) + (y)^(2) + (z)^(2)) + 2*(z)^(2)*cos((x)^(2) + (y)^(2) + (z)^(2)), -4*x*y*(z)^(2)*sin((x)^(2) + (y)^(2) + (z)^(2)), -4*x*(z)^(3)*sin((x)^(2) + (y)^(2) + (z)^(2)) + 4*x*z*cos((x)^(2) + (y)^(2) + (z)^(2))], [-4*x*y*(z)^(2)*sin((x)^(2) + (y)^(2) + (z)^(2)), -4*(y)^(2)*(z)^(2)*sin((x)^(2) + (y)^(2) + (z)^(2)) + 2*(z)^(2)*cos((x)^(2) + (y)^(2) + (z)^(2)), -4*y*(z)^(3)*sin((x)^(2) + (y)^(2) + (z)^(2)) + 4*y*z*cos((x)^(2) + (y)^(2) + (z)^(2))], [-4*x*(z)^(3)*sin((x)^(2) + (y)^(2) + (z)^(2)) + 4*x*z*cos((x)^(2) + (y)^(2) + (z)^(2)), -4*y*(z)^(3)*sin((x)^(2) + (y)^(2) + (z)^(2)) + 4*y*z*cos((x)^(2) + (y)^(2) + (z)^(2)), -4*(z)^(4)*sin((x)^(2) + (y)^(2) + (z)^(2)) + 10*(z)^(2)*cos((x)^(2) + (y)^(2) + (z)^(2)) + 2*sin((x)^(2) + (y)^(2) + (z)^(2))]];

  return hess;
}

function vec3 fStep(vec3 s) {
  vec3 g = grad(s);
  tensor[3,3] H = hess(s);
  vec3[3] E = evecs(H);
  real[3] L = evals(H);
  vec3 up =  -(1/L[2])*E[2]⊗E[2]•g;
  if(!(up[0] == up[0]) ||  !(up[1] == up[1]) || !(up[2] == up[2])){
    return([∞, ∞, ∞]);
  }

  return up;
  
}

function bool posNanCheck(vec3 up){
  return (!(up[0] == up[0]) ||  !(up[1] == up[1]) || !(up[2] == up[2]));
}

function tensor[3,3] fPerp(vec3 s) {
  vec3 g = grad(s);
  tensor[3,3] H = hess(s);
  vec3 E2 = evecs(H)[2];
  mat3 m =  identity[3] - E2⊗E2;
  real t = m : m;
  if(!(t == t)){
    return(zeros[3,3]);
  }
  return m;
}

function real fStrength(vec3 s) {
  vec3 g = grad(s);
  tensor[3,3] H = hess(s);
  real str = -evals(H)[2]/(fBias + |g|);
  return str;
}

function real fMask(vec3 x) = 0.0;
function bool fTest(vec3 x) = true;

function bool posTest(vec3 x) =
  (insideTest(x)            // in field
     && fStrength(x) > fStrTh // possibly near feature
     && fMask(x) >= fMaskTh   // meets feature mask
     && fTest(x));            // passes addtl feature criterion

// Each particle wants between nnmin and nnmax neighbors
int nnmin = 6 if (2==fDim) else 2 if (1==fDim) else 0;
int nnmax = 8 if (2==fDim) else 3 if (1==fDim) else 0;

/* Potential function (found with Mathematica) phi(r):
   phi(0)=1, phi(r)=0 for r >= 1, with minima (potential well)
   phi'(2/3)=0 and phi(2/3)=-0.001.  Phi(r) is C^3
   continuous across the well and with 0 for r >= 1. Potential
   well induces good packing with energy minimization. */
function real phi(real r) {/*@\label{line:pbfs-phi}@*/
  real s=r-2.0/3;
  return
    1 + r*(-5.646 + r*(11.9835 + r*(-11.3535 + 4.0550625*r)))
  if r < 2.0/3 else
    -0.001 + ((0.09 + (-0.54 + (1.215 - 0.972*s)*s)*s)*s)*s
  if r < 1 else 0;
}
function real phi'(real r) { // phi'(r) = d phi(r) / dr
  real t=3*r-2;
  return
    -5.646 + r*(23.967 + r*(-34.0605 + 16.22025*r))
  if r < 2.0/3 else
    0.01234567901*t*(4.86 + t*(-14.58 + t*(14.58 - 4.86*t)))
  if r < 1 else 0;
}
real phiWellRad = 2/3.0;    // radius of potential well
real rad = tipd/phiWellRad; // actual radius of potential support
function real enr(vec3 x) = phi(|x|/rad);/*@\label{line:pbfs-enr}@*/
function vec3 frc(vec3 x) = phi'(|x|/rad) * (1/rad) * x/|x|;/*@\label{line:pbfs-frc}@*/

// pchist reflects periodicity of PC: pchist^(2*pcp) = hist
real pchist = hist^(1.0/(2*pcp));

int iter = 0;        // iteration counter
real rpc = 1;        // recent population change
int popLast = -1;    // population at last iteration

/* Finds a number in [0,1) roughly proportional to the low 32
   bits of significand of given real x. NOTE: ONLY useful only
   when compiling with --double */
function real urnd(real x) {/*@\label{line:pbfs-urnd}@*/
  if (x==0) return 0;
  real l2 = log2(|x|);
  real frxp = 2^(l2-floor(l2)-1); // in [0.5,1.0), like frexp(x)
  // use iter to make different values for same x
  return fmod((2^20 + 2*iter)*frxp, 1);
}

// Given vec3 (and iter), a random-ish value uniformly in [0,1)
function real v3rnd(vec3 v)/*@\label{line:pbfs-v3rnd}@*/
= fmod(urnd(v[0]) + urnd(v[1]) + urnd(v[2]), 1);

// Given vec3 (and iter), a big random-ish integer
function real genID(vec3 v) = floor(1000000*v3rnd(v));/*@\label{line:pbfs-genid}@*/

/* Is this an iteration in which to do population control (PC)?
   If not, pcIter() returns 0. Otherwise, returns 1 when should
   birth new particles, and -1 when should kill then off. This
   alternation is not due to any language limitations; it just
   plays well with the PC heuristics used here. */
function int pcIter(){
  if (pcp>0 && iter>0 && 0 == iter % pcp) {return (((iter/pcp)%2)*2 - 1);}
  else {return 0;}
}

// Strands first find feature, then interact w/ or make neighbors
strand point (vec3 p0, real hh0) {
  output vec3 pos = p0; // current particle position
  real ID = genID(p0);  // strand identifier
  real hh = hh0;        // energy gradient descent stepsize
  vec3 step = [0,0,0];  // energy+feature steps this iter
  bool found = false;   // whether feature has been found/*@\label{line:pbfs-found-init}@*/
  int nfs = 0;          // number feature steps taken
  real trav = 0;        // total distance traveled
  real mvmt = 1;        // average of recent movement
  real closest = rad;   // distance to closest neighbor
  int born = 0;         // how many particles I have birthed
  bool first = true;    // first time through update
  update {
    //bool vv = |[pos[0], pos[1]] - [-0.569501,0.208949]| < 0.1; // HIDE
    bool vv = false; // (ID == 464037); // HIDE
    if (first && ((verb > 0 && vv) || verb > 1)) { // HIDE
      print(ID, "(i#", iter, " @ ", pos, "): "); // HIDE
      print(" HELLO!\n"); // HIDE
    } // HIDE
    if (!posTest(pos)) {
      if ((verb > 0 && vv) || verb > 1) { // HIDE
        print(ID, "(i#", iter, " @ ", pos, "): "); // HIDE
        print("!inside=", insideTest(pos), " || fStrength=", fStrength(pos), " <= fStrTh=", fStrTh, " || fMask(pos)=", fMask(pos), " < fMaskTh=", fMaskTh, " || fTest(pos)=", fTest(pos), " ==>DIE\n"); // HIDE
      } // HIDE
      die;
    }
    if (travMax > 0 && trav > travMax) {  // too much travel
      die;
    }
    if (!found) { // ------------------------ looking for feature/*@\label{line:pbfs-nfound0}@*/
      if (nfsMax > 0 && nfs > nfsMax) {    // too many steps
        if ((verb > 0 && vv) || verb > 1) { // HIDE
          print(ID, "(i#", iter, " @ ", pos, "): "); // HIDE
          print("nfs=", nfs, " > nfsMax=", nfsMax, " || trav=", trav, " > travMax=", travMax, " =>DIE\n"); // HIDE
        } // HIDE
        die;
      }
      step = sfs*fStep(pos); // one step towards feature
      pos += step;
      mvmt = lerp(|step|/tipd, mvmt, hist);
      if (mvmt > fsEps) {        // still moving
        trav += |step|/tipd;
        nfs += 1;
      } else {         // found feature, prepare for code below
        found = true;
        mvmt = 1;
        trav = 0;
      }/*@\label{line:pbfs-nfound1}@*/
      if ((verb > 0 && vv) || verb > 1) { // HIDE
        print(ID, "(i#", iter, " @ ", pos, "): "); // HIDE
        print("step=", step, "; mvmt=", mvmt, " => found=", found, "\n"); // HIDE
      } // HIDE
    } else { // ------------------ feature found; minimize energy/*@\label{line:pbfs-found0}@*/
      // if feature is isolated points, we're already done
      if (0 == fDim) { stabilize; }      step = sfs*fStep(pos); pos += step; trav += |step|/tipd;
      real oldE = 0;             // energy at current location
      vec3 force = [0,0,0];      // force on me from neighbors
      int nn = 0;                // number of neighbors
      foreach (point P in sphere(rad)) {
        vec3 off = P.pos - pos;
        if (|off|/tipd < fsEps && ID <= P.ID) {
          // with 0-D features or unlucky intialization, points
          // can really overlap; point w/ lower ID dies
          if (verb > 0 && vv) print(" (", ID, " F) on top of ", P.ID, "; I have lower ID; bye\n"); // HIDE
          die;
        }
        oldE += enr(off);
        force += frc(off);
        nn += 1;
      }
      if (0 == nn) { // else fDim is 1 or 2/*@\label{line:pbfs-0nn0}@*/
        // No neighbors; create one if possible
        if (!( pcIter() > 0 && born < nnmax )) { continue; }
        // Ensure new pos is near feature, for all
        // feature dimensions and orientations
        vec3 noff0 = fPerp(pos)•[tipd,0,0];
        vec3 noff1 = fPerp(pos)•[0,tipd,0];
        vec3 noff2 = fPerp(pos)•[0,0,tipd];
        vec3 noff = noff0;
        noff = noff if |noff| > |noff1| else noff1;
        noff = noff if |noff| > |noff2| else noff2;
        // noff is now longest of noff0, noff1, noff2
        vec3 npos = tipd*normalize(noff) + pos;
        npos += sfs*fStep(npos);
        if ((verb > 0 && vv) || verb > 1) { // HIDE
          print(ID, "(i#", iter, " @ ", pos, "): "); // HIDE
          print(" 0==nn =>NEW(", npos, ") w/ ID=", genID(npos), "\n"); // NOTE: the new strand state gets initialized with the current value of iter // HIDE
        } // HIDE
        if (posTest(pos)) {
          new point(npos, hh); born += 1;
        }
        if ((verb > 0 && vv) || verb > 1) { // HIDE
          print(ID, "(i#", iter, " @ ", pos, "): "); // HIDE
          print("nn=0; after birthing mvmt=", mvmt, "\n"); // HIDE
        } // HIDE
        continue;
      }/*@\label{line:pbfs-0nn1}@*/
      // Else I did have neighbors; interact with them
      vec3 es = hh*fPerp(pos)•force; // energy step along force
      if (|es| > tipd) {             // limit motion to tipd
        hh *= tipd/|es|;             // decrease stepsize, step
        es *= tipd/|es|;
      }                              // now |es| <= tipd
      vec3 fs = sfs*fStep(pos+es);   // step towards feature
      //HEY HEY is fsEps needed if you do an fStep at every iter? //HIDE                    
      if (|fs|/(fsEps*tipd + |es|) > 0.5) {
        hh *= 0.5; // feature step too big, try w/ smaller step
        if ((verb > 0 && vv) || verb > 1) { // HIDE
          print(ID, "(i#", iter, " @ ", pos, "): "); // HIDE
          print("nn=", nn, "; |fs|/|es|=", |fs|/|es|, " > 0.5; trying again with hh=", hh, "; mvmt=", mvmt, "\n"); // HIDE
          print("        fs=", fs, "\n"); // HIDE
          print("        es=", es, "\n"); // HIDE
        } // HIDE
        continue;
      }
      vec3 oldpos = pos;
      pos += fs + es;            // take steps, find new energy
      real newE = 0;
      closest = rad;
      // find mean neighbor offset (mno) to know (opposite)
      // direction in which to add new particles with PC
      vec3 mno = [0,0,0];
      nn = 0;
      foreach (point P in sphere(rad)) {/*@\label{line:pbfs-newE0}@*/
        vec3 off = P.pos - pos;
        newE += enr(off);
        closest = min(closest, |off|);
        mno += off;
        nn += 1;
      }
      mno /= nn;/*@\label{line:pbfs-newE1}@*/
      if ((verb > 0 && vv) || verb > 1) { // HIDE
        print(ID, "(i#", iter, " @ ", pos, "): "); // HIDE
        print("nn=", nn, "; oldE=", oldE, " newE=", newE, "\n"); // HIDE
      } // HIDE
      // test the Armijo sufficient decrease condition
      if (newE - oldE > gdeTest*(pos - oldpos)•(-force)) {/*@\label{line:pbfs-armijo}@*/
        // backtrack because energy didn't go down enough
        hh *= gdeBack;    // try again next time w/ smaller step
        if (0 == hh) {
          print(ID, "(i#", iter, " @ ", pos, "): "); // HIDE
          print("backtracked all the way to hh=0\n"); // HIDE
          die; // backtracked all the way to hh=0!
        }
        if ((verb > 0 && vv) || verb > 1) { // HIDE
          print(ID, "(i#", iter, " @ ", pos, "): "); // HIDE
          print("nn=", nn, "; oldE=", oldE, " newE=", newE, "; backtracking; hh=", hh, "; mvmt=", mvmt, "\n"); // HIDE
          print("      fs=", fs, "\n"); // HIDE
          print("      es=", es, "\n"); // HIDE
          print("      newE - oldE=", newE - oldE, "\n"); // HIDE
          print("      force=", force, "\n"); // HIDE
          print("      dpos=", pos - oldpos, "\n"); // HIDE
          print("      0.5*(pos - oldpos).(-force)=", 0.5*(pos - oldpos)•(-force), "\n"); // HIDE
        } // HIDE
        pos = oldpos;
        continue;
      }
      hh *= gdeOppor; // opportunistically increase stepsize/*@\label{line:pbfs-descent}@*/
      step += fs + es;/*@\label{line:pbfs-recstep}@*/
      trav += |step|/tipd;
      mvmt = lerp(|step|/tipd, mvmt, hist);
      if (|step|/tipd < pcmvEps && pcIter() != 0) {
        // can do PC only if haven't moved a lot
        if (pcIter()>0       // this is an iter to add
            && newE<0        // already in a potential well
            && nn<nnmin      // have fewer than expected neighbors
            && born<nnmax) { // haven't birthed too many times
          vec3 npos = pos - tipd*normalize(mno);/*@\label{line:pbfs-mno-use}@*/
          npos += sfs*fStep(npos); npos += sfs*fStep(npos);
          bool birth = true;
          if (fDim == 2 && nn >= 4) {
            foreach (point P in sphere(npos, tipd*mabd)) {/*@\label{line:pbfs-mabd-used}@*/
              birth = false; // too close to existing point
            }
            if (birth) {
              // Have nn neighbors: too few (nnmin > nn).
              // Try adding a new neighbor with a probability
              // that scales with nnmin-nn.
              birth = v3rnd(pos) < (nnmin - nn)/real(nnmin);/*@\label{line:pbfs-birth}@*/
            }
          }
          if (birth && posTest(npos)) {
            new point(npos, hh); born += 1;
          }
        } else if (pcIter() < 0 && newE > 0 && nn > nnmax) {
          // Have too many neighbors, so maybe die. If I have
          // nn neighbors, they probably also have nn neighbors.
          // To have fewer, that is, nnmax neighbors, we all
          // die with chance of nn-nnmax out of nn.
          if (v3rnd(pos) < (nn - nnmax)/real(nn)) {/*@\label{line:pbfs-death}@*/
            if (verb > 0 && vv) print("  (", ID, " F); v3rnd=", v3rnd(pos), " < ", (nn - nnmax)/real(nn), " => die \n"); // HIDE
            die;
          }
          // pc = 1; // over-population prevents convergence; HEY MISSING THIS NOW  // HIDE                  
        }
      }
    } // else found/*@\label{line:pbfs-found1}@*/
    first  = false;
  } // update
}
update {/*@\label{line:pbfs-global}@*/
  int pop = numActive();
  int pc = 1 if pop != popLast else 0;
  rpc = lerp(pc, rpc, pchist);
  bool allfound = all { P.found | P in point.all};
  real percfound =
    100* mean { 1.0 if P.found else 0.0 | P in point.all};
  real meancl = mean { P.closest | P in point.all };
  real varicl = mean { (P.closest - meancl)^2 | P in point.all };
  real covcl = sqrt(varicl) / meancl;
  real maxmvmt = max { P.mvmt | P in point.all };
  print("======= finished iter ", iter, " w/ ", pop, ")",
        "; %found=", percfound,
        "; mean(hh)=", mean { P.hh | P in point.all},
        "; mean(cl)=", meancl,
        "; COV(cl)=", covcl,
        "; max(mvmt)=", maxmvmt,
        "; pc=", pc,
        "; rpc=", rpc,
        "\n");
  if (allfound            // all particles have found the feature/*@\label{line:pbfs-conv}@*/
      && covcl < geoEps   // and system is geometrically uniform
      && maxmvmt < mvmtEps  // and nothing's moving much
      && rpc < rpcEps) { // and pop. hasn't changed recently
    print("======= Stabilizing ", numActive(), " (iter ", iter, ")",
          "; COV(cl)=", covcl, " < ", geoEps,
          "; max(mvmt)=", maxmvmt, " < ", mvmtEps,
          "; rpc=", rpc, " < ", rpcEps,
          "\n");
    stabilize;
  }
  else {
        print("======= Stabilizing ", numActive(), " (iter ", iter, ")",
          "; COV(cl)=", covcl, " > ", geoEps,
          "; max(mvmt)=", maxmvmt, " > ", mvmtEps,
          "; rpc=", rpc, " > ", rpcEps,
          "\n");
  }
  iter += 1;
  popLast = pop;
}
create_collection { point(ipos[ii], 1) | ii in 0 .. length(ipos)-1 };
  
